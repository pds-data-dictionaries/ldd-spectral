<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://pds.nasa.gov/pds4/pds/v1/PDS4_PDS_1E00.sch" schematypens="http://purl.oclc.org/dsdl/schematron"?>

<Ingest_LDD xmlns="http://pds.nasa.gov/pds4/pds/v1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://pds.nasa.gov/pds4/pds/v1 http://pds.nasa.gov/pds4/pds/v1/PDS4_PDS_1E00.xsd">
    <name>Spectral Discipline Dictionary</name>
    <ldd_version_id>1.3.1.0</ldd_version_id>
    <dictionary_type>Discipline</dictionary_type>
    <full_name>Anne Raugh</full_name>
    <steward_id>sbn</steward_id>
    <namespace_id>sp</namespace_id>
    <comment>
        This is a complete re-write of the Spectral Dictionary version 1.1.0.0  (i.e., PDS4_SP_1100, 
        released with core IM 1.4.0.0) to bring it into compliance with requirements and best practices 
        established since the original version was created.  
        
        Existing attribute definitions have been reviewed and in some cases updated.  This should be 
        reflected in the version_id value of the attribute.
        
        The "submitter_name" of "ACR" indicates Anne (C.) Raugh.
        
        Modification History:
        
           2018-05-25  ACR  Version 1.0.0.0  First release
           
           2018-11-02  ACR  Version 1.1.0.0  Added support for tabulated spectra
           2019-03-08  ACR  Version 1.1.0.0  Replaced "data()" with equivalent "data(.)" to work around
                                             a Validate Tool issue
           2019-03-15  ACR  Version 1.1.0.0  Fixed bug in range checking for Uniformly Sampled data by
                                             adding "number()" function
           2019-07-29  ACR  Version 1.2.0.0  Added table support for rows and fields in Uniformly_Sampled;
                                             Moved Bin_Width_Constant class (unusable as designed) into Spectral_Lookup;
                                             Made bin-width nillable for cases where it is unknown;
                                             Removed references to "original bin number" (mission-specific);
                                             Expanded Axis_Bin_Set class for tabular (row and field) spectra 
           2020-08-05  ACR  Version 1.3.0.0  Added support for X-ray spectra with energy bins; minor changes to 
                                             Ingest_LDD.
           2021-06-21  ACR  Version 1.3.1.0  Bug fix for a Schematron error. "Table_Delimited" was not included
                                             in the acceptable object types for Spectral_Characteristics.
    </comment>
    <last_modification_date_time>2021-06-21</last_modification_date_time>
    <!--
        This file also contains extensive comments to illustrate various techniques available to those
        creating input IngestLDD files for local dicitionaries.  
        
        For the Spectral Dictionary, there are a number of classes and attributes that have a unit 
        dependence, and since light spectra may be reported in one of three different classes of
        units of measure (frequency, length, and wavenumber), there are some attributes and classes
        that have three versions - one for each unit of measure type.  This is necessary in order
        to get strict validation of units.
        
        The overall organization of the file is dictated by the Ingest_LDD structure, so attributes
        are defined first, then classes, then Schematron rules.  No property maps are defined in this
        dictionary.  Within those boundaries:
        
          o Attributes that are not spectral unit type specific are listed first in alphabetical
            order;
          o Attributes that are unit type specific are listed next in alphabetical sets;
          o Classes that only contain attributes and are not unit-type specific are listed first 
            in the class section in the approximate order in which they appear in the main
            Spectral_Characteristics class hierarchy;
          o Classes that only contain attributes and are unit-specific follow in approximate
            hierarchy order;
          o Classes that contain other classes (i.e., are higher in the hierarchy) are listed
            next;
          o The Spectral_Characteristics class is defined last;
          o Schematron Rules are defined in approximate hierarchy order.

        Additional Notes:
          - There is no requirement that classes be defined lexically before they are used to 
            create higher-level classes; I do that for my own accounting purposes.
          - I always use the same value for both <name> and <local_identifier> because so far I 
            have not needed to create context-dependent versions of anything.  I could do that
            for the various unit classes now (it was not an option when the dictionary was first
            designed), but having unique names for each spectral bin type does allow for some 
            very strong validation and very explicit labelling, so I'm not inclined to change it
            at this point.
          - Here are some basic techniques you can find by searching for specific strings in
            this file:
               1. Enumerated value lists - search for "<enumeration_flag>true"
               2. Specifying units of measure type - search for "unit_of_measure_type"
               3. Specifying max/min - search for "maximum_value"/"minimum_value"
               4. Declaring an attribute as "nillable" - search for "nillable_flag"
               5. Defining text fields that can contain non-ASCII characters - search for "UTF8"
               6. Allowing an attribute or class to be repeated an unlimited number of times -
                  search for "maximum_occurrences>*"
               7. Defining a pattern constraint for an attribute - search for "pattern"
          - Of the "Advanced Techniques" described on the wiki page:
              http://sbndev.astro.umd.edu/wiki/Creating_the_Ingest_LDD_Dictionary_Input_File
            three are illustrated in this file:
               1. Schematron Rules (there's an entire section at the bottom - search for "DD_Rule")
               2. Referencing another namespace (search for "pds.")
               3. Choice lists (search for "XSChoice#")
          - I've periodically included "Dictionary Preparation Hints" for things I've discovered 
            or arrived at through trial-and-error.  Hopefully these will save you some time.  
            They are typically located near the point in this file where they became relevant
            to me.
    -->

    <!-- Attribute Definitions -->

    <!--
        Dictionary Preparation Hint: Avoid "TBD"!
        =========================================
        Don't use "TBD" for definitions, no matter how much you might want to.  It's too easy to 
        lose track; getting the <definition> is often the hardest part of creating an attribute;
        and it could be very embarrassing to have your data submission rejected because of an
        undefined local attribute.  I would personally recommend a policy of never defining an
        attribute until the <definition> is in hand.  You can create the template and comment
        it out to save some time and raise the visibility of TBD attributes, but "TBD" nearly 
        always comes back To Bite Down on the dictionary preparer.        
    -->

    <!--
        Dictionary Preparation Hint: Nomenclature
        =========================================
        The PDS conventions for attribute and class names are simple:
        
        o Terms (i.e., "words") are separated by '_'.
        o Terms in attribute names are lower case.
        o Terms in class names are capitalized.
        o Terms in both names are generally organized least general to most general left-to-right,
          though there are numerous exceptions that have been made in favor of intuitive 
          interpretation.
          
        And there are some additional nomenclature conventions:
        o Terms ending in "_name" are usually human-readable names
        o Terms ending in "_id" are identifiers that follow syntax rules that are usually 
          enforced via "pattern" constraints.
        o Terms ending in "_type" are indicative of a formal taxonomy and will have a permissible 
          value list for validation.
        
        Non-discipline dictionary preparers are under no obligation to follow these conventions, 
        but you should devise some sort of conventions of your own and apply them consistently.
        It helps users reading (and reviewing!) your labels to more quickly perceive your class
        and attribute structures, which in turn aids understanding.
        
        While you can, technically, use non-ASCII (i.e., UTF-8) characters in class and attribute 
        names, unless you know you're working in an editor that was designed and configured to 
        handle UTF-8 properly and you know how to ensure you will get the correct codepoint in
        the field, non-ASCII characters should probably be avoided.  In fact, you should restrict 
        yourself to letters, numbers, and underscores for your attribute names in general, as 
        other characters might be misinterpreted, and there's a pretty good chance that 
        restriction will be introduced in future once I point out to the Powers That Be that it
        does not exist now.
        
        The character set for <local_identifier> _is_ restricted to ASCII (though not to letters,
        numbers, and underscores), so if you use the same value for that and <name> then at 
        least you will get some cross-validation for minimum character set restrictions.  Same
        caveats apply here.
    -->

    <!-- Attributes without units in their tag names -->

    <DD_Attribute>
        <name>absolute_calibration_star_name</name>
        <version_id>1.0</version_id>
        <local_identifier>absolute_calibration_star_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The absolute_calibration_star_name attribute provides a name in a standard format 
            (i.e., one that is recognized by the SIMBAD system) for the star used to reduce
            the raw spectral data to the units presented in this spectrum.  This is the analog
            to solar_calibration_star_name for non-reflectance spectra.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>UTF8_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>axis_name</name>
        <version_id>1.1</version_id>
        <local_identifier>axis_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The axis_name attribute contains a string that matches the axis_name attribute in the associated
            array-type spectrum object; or the special values "Field" and "Row" for tabular and tabulated 
            spectra.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>bin_center_field_name</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_center_field_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_center_field_name must contain the value of a 'name' attribute of a Field defined 
            in the referenced Table object.  This named Field contains the bin center information for 
            each row in a 1D spectrum presented in tabular form.  It will have units (and possibly 
            offset and scaling factor) as indicated in the Field definition.  This will usually be
            accompanied by a bin_width_field_name.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>bin_center_field_number_list</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_center_field_number_list</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_center_field_number_list attribute is used only in the 
            case of spectra in the format "Tabulated-Flat", where each row 
            of a table contains a spectrum and the spectral points are defined
            as individual Fields - one Field defined for each point.  The
            format is a parenthesized, ordered list of the field_number
            values from the Field definitions that correspond to the 
            bin center values.
        </definition>
        
        <!--
            This attribute needs to contain a list of numbers, which is unusual.
            Typically we would define an attribute to hold a single number and 
            just repeat it.  But this attribute it used only in the case of 
            tabulated spectra, and may contain several dozen numbers in the worst
            case.  So instead of long repetitions of attribute tags, we're going
            to require proper list notation - opening and closing parentheses,
            integer values, separated by commas (with optional whitespace).  If
            we validate the syntax, we can rely on the format when it comes to 
            parsing and validating individual values, both in the Schematron and
            in application programs.  To validate the syntax, we'll use a pattern
            constraint.
        
            XSD patterns use a subset of the standard Perl/Python/grep regular
            expressions.  Things to note:
            
             o Do not anchor the pattern.  Matching is automatically anchored at
               the start of the value, in this case AFTER whitespace normalization
               has happened - so an initial "^" will be interpreted as a literal.
             o Do not use delimiters.  Only the pattern to be matched is included.
               The pattern below begins with '\' not because it is a delimiter, but
               because it is escaping the '(' following it which would otherwise be
               interpreted as a grouping character.
             o The pattern must be greedy - in other words, it acts as though it is
               anchored to both the start and the end of the value.  If you want to 
               match only part of a value, you'll need to use the ".*" (match zero 
               or more arbitrary charaters) notation for the parts of the value you
               don't care about matching.
        -->
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
            <formation_rule>
                Data should be provided as a parenthesized list of integers
                separated by commas. For example: (1, 5, 9, 13, 17, 21, 25)
            </formation_rule>
            <!--
                This pattern requires an opening '(', followed by optional whitespace,
                followed by an integer, followed by zero or more instances of commas
                followed  by integers, concluded with a closing ')'.  Optional 
                whitespace is allowed to appear between elements.
            -->
            <pattern>\(\s*[0-9]+(\s*,\s*[0-9]+)*\s*\)</pattern>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <!--
        Dictionary Preparation Hint: Using <comment>
        ============================================
        The next attribute has actually been updated.  Note that <version_id> has been
        changed to reflect that, and I've added a <comment> to describe the change.
        Comments are not propagated to the output schema files; they are for the
        dictionary maintainer and they can be maintained in a dictionary database, since
        they are easily accessible to an XML parser.  In this case the change made was 
        transparent to the end user, so no need to note it in the definition a user 
        would see.
    -->
    <DD_Attribute>
        <name>bin_sequence_number</name>
        <version_id>2.0</version_id>
        <local_identifier>bin_sequence_number</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_sequence_number provides the sequential
            numbering of bins along an axis in an Array
            object.
        </definition>
        <comment>
            Version 2.0 of this attribute changes the data type from
            ASCII_Integer with a defined minimum of zero to the
            equivalent ASCII_NonNegative_Integer.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_NonNegative_Integer</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>bin_profile_description</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_profile_description</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_profile_description attributes provides a text description 
            of the method used to determine or otherwise define the bin widths
            following.  The description should include information on the shape 
            (e.g. gaussian, square wave, etc.) and what the bin_width value means
            (i.e., standard deviation of a gaussian function or full-width at 
            half max (FWHM)).
        </definition>
        <comment>
            The attribute has been converted to UTF-8 text to accommodate descriptions
            that might require units or other strings with non-ASCII characters and
            has been renamed from the original "bin_width_desc", because that name was
            sufficiently non-specific that no user supplied the correct information on
            the first attempt, and frequently not the second, either.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>UTF8_Text_Preserved</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>bin_width_field_name</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_width_field_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_width_field_name must contain the value of a 'name' attribute of a Field defined 
            in the referenced Table object.  This named Field contains the bin width information for 
            each row in a 1D spectrum presented in tabular form.  It will have units (and possibly 
            offset and scaling factor) as indicated in the Field definition.  This attribute must be
            accompanied by a bin_center_field_name.
            
            If bin widths are constant or unknown, use the Bin_Width_Constant class to specify this.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>bin_width_field_number_list</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_width_field_number_list</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_width_field_number_list attribute is used only in the 
            case of spectra in the format "Tabulated-Flat", where each row 
            of a table contains a spectrum and the spectral points are defined
            as individual Fields - one Field defined for each point.  The
            format is a parenthesized, ordered list of the field_number
            values from the Field definitions that correspond to the 
            bin width values.
            
            If bin widths are constant or unknown, use the Bin_Width_Constant class to specify this.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
            <formation_rule>
                Data should be provided as a parenthesized list of integers
                separated by commas. For example: (1, 5, 9, 13, 17, 21, 25)
            </formation_rule>
            <pattern>\(\s*[0-9]+(\s*,\s*[0-9]+)*\s*\)</pattern>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>body_positive_pole_position_angle</name>
        <version_id>1.0</version_id>
        <local_identifier>body_positive_pole_position_angle</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The body_positive_pole_position_angle attribute provides the angle the long 
            axis of the slit makes with respect to the positive (or "north") pole of the
            target body, measured clockwise from the pole in the range 0-180 degrees.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>0.0</minimum_value>
            <maximum_value>180.0</maximum_value>
            <unit_of_measure_type>Units_of_Angle</unit_of_measure_type>
            <specified_unit_id>deg</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>celestial_north_position_angle</name>
        <version_id>1.0</version_id>
        <local_identifier>celestial_north_position_angle</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The celestial_north_position_angle attribute provides the angle the long 
            axis of the slit makes with respect to celestial north, measured
            eastward of celestial north in the range 0-180 degrees.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>0.0</minimum_value>
            <maximum_value>180.0</maximum_value>
            <unit_of_measure_type>Units_of_Angle</unit_of_measure_type>
            <specified_unit_id>deg</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>comment</name>
        <version_id>2.0</version_id>
        <local_identifier>comment</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The comment attribute is an unlimited length, format-preserved, UTF-8 text field 
            for comments relevant to the context in which it appears.
        </definition>
        <comment>
            Note that we're allowing UTF-8 characters in this comment field, where
            the core namespace pds:comment element does not.  This is to accommodate
            comments that need to refer to units of measure or proper names that 
            might contain non-ASCII characters.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>UTF8_Text_Preserved</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>description</name>
        <version_id>1.0</version_id>
        <local_identifier>description</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The description attribute is an unlimited length, format-preserved, UTF-8 text field
            used specifically for description of circumstances related to the data product of 
            which a user should be aware and might logically expect to find in the label.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>UTF8_Text_Preserved</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>diameter_angle</name>
        <version_id>1.0</version_id>
        <local_identifier>diameter_angle</local_identifier>
        <nillable_flag>true</nillable_flag>
        <!--
            This attribute is defined as "nillable".  The convention for PDS-maintained
            dictionaries is that attributes are either optional or nillable, but not 
            both. I plan to make diameter_angle a required attribute in at least one class  
            that contains it, so I'm making it nillable for the low-probability case 
            where the value might not be known.  I only expect this to occur in legacy 
            data sets, where there's no way to recover the information, so the extra 
            trouble to define the attribute as 'nil' in a label is not onerous in general.
        -->
        <submitter_name>ACR</submitter_name>
        <definition>
            The diameter_angle attribute provides the angle subtended on the sky by the
            diameter of a circular aperture.
        </definition>
        <DD_Value_Domain>
            <!--
                Also note that in this case we have a unit of measure as well as some 
                additional constraints on the numeric value.  When you have max/min in
                conjunction with a unit of measure type, you should always include the
                <specified_unit_id> attribute to indicate the unit associated with the
                maximum/minimum (this is a case where we can't use a "unit=" XML 
                attribute because of chronology of definition).  When all you have is
                a minimum of zero, the point is moot, but it is a reasonable thing to 
                do for completeness, and to develop the habit for non-zero limits.
                
                THIS IS NOT CURRENTLY VALIDATED BY THE Ingest_LDD SCHEMA, so please
                make sure you double-check for <unit_of_measure_type> and include
                <specified_unit_id> whenever you define numeric extrema. 
            -->
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Angle</unit_of_measure_type>
            <specified_unit_id>deg</specified_unit_id>
            <!--
                This unit string is not validated, either. Please check this carefully!
            -->
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>detector_number</name>
        <version_id>2.0</version_id>
        <local_identifier>detector_number</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The detector_number attribute provides the
            spectrometer detector number corresponding to a band of a spectral
            qube.  Detector numbers are usually assigned consecutively from 1,
            in order of increasing wavelength.
        </definition>
        <comment>
            Version 2.0 of this attribute changes the data type from
            ASCII_Integer to ASCII_NonNegative_Integer with a minimum
            value of 1.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_NonNegative_Integer</value_data_type>
            <minimum_value>1</minimum_value>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>filter_name</name>
        <version_id>1.0</version_id>
        <local_identifier>filter_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The filter_name attribute provides the
            commonly-used name of the instrument filter through which an image
            or measurement was acquired or which is associated with a given
            instrument mode.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>filter_number</name>
        <version_id>2.0</version_id>
        <local_identifier>filter_number</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The filter_number attribute provides the numeric
            identifier of an instrument filter through which an image or
            measurement was acquired or which is associated with a given
            instrument mode.  Within the bin class of a spectral data object,
            it identifies the filter through which data in the given band were
            acquired.
        </definition>
        <comment>
            Version 2.0 of this attribute changes the data type from 
            ASCII_Integer to ASCII_NonNegative_Integer.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_NonNegative_Integer</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>grating_position</name>
        <version_id>2.0</version_id>
        <local_identifier>grating_position</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The grating_position attribute of a spectral cube
            describes the grating position which corresponds to the band. 
            Grating positions are usually assigned consecutively from 0, and
            increasing position causes increasing wavelength for each
            detector.
        </definition>
        <comment>
            Version 2.0 of this attribute changes the data type from 
            ASCII_Integer to ASCII_NonNegative_Integer.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_NonNegative_Integer</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>length_angle</name>
        <version_id>1.0</version_id>
        <local_identifier>length_angle</local_identifier>
        <nillable_flag>true</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The length_angle attribute provides the angle subtended on
            the sky by the long dimension of a simple slit.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Angle</unit_of_measure_type>
            <specified_unit_id>deg</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>net_integration_time</name>
        <version_id>1.0</version_id>
        <local_identifier>net_integration_time</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The net_integration_time for a spectrum is the total integration time per pixel.
            For many detectors (CCDs, for example), all pixels are exposed simultaneously, so
            this value will correspond to the observation interval.  In some cases, however, an instrument
            will sweep across pixels, rows, or planes, so that the observation period may be substantially
            longer than the actual integration time contributing to the individual pixels.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            
            <!--
                Here's a slightly tricky thing.  I don't want to allow integration time to be
                either negative, or exactly zero, but there is no real-number equivalent to the
                "Positive Integer" type.  So instead, when I want a non-zero real number, I'll
                set the minimum to be near the smallest representable positive 8-byte real.  
                That's slightly risky, but in this dictionary it is extremely unlikely that 
                values of integration_time (and similar attributes) that are that small are 
                physically real, so the limit should be well out of the range of valid attribute
                values in all the cases we're ever likely to encounter.
                
                I used the 8-byte value because the maximum for the ASCII_Real type is also set
                to the 8-byte maximum representable value.
            -->
            
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Time</unit_of_measure_type>
            <specified_unit_id>s</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>number_of_exposures</name>
        <version_id>1.0</version_id>
        <local_identifier>number_of_exposures</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The number_of_exposures attribute indicates how many individual exposures or
            distinct integrations were combined to produce the spectrum.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Integer</value_data_type>
            <minimum_value>1</minimum_value>
        </DD_Value_Domain>
    </DD_Attribute>

    <!-- 
        2019-07-29
        
        Removed - mission-specific.
        
    <DD_Attribute>
        <name>original_bin_number</name>
        <version_id>1.0</version_id>
        <local_identifier>original_bin_number</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The original_bin_number attribute of a spectral
            Array object is used when the current data object is a subset of
            some original data object.  The original_bin_number for each band
            identifies the bin_sequence_number of the corresponding band in the
            original data object.
        </definition>
        <comment>
            Version 2.0 of this attribute changes the data type from 
            ASCII_Integer to ASCII_NonNegative_Integer.
        </comment>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_NonNegative_Integer</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>
    -->

    <DD_Attribute>
        <name>sampling_base</name>
        <version_id>1.0</version_id>
        <local_identifier>sampling_base</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The sampling_base attribute indicates the numeric base of the associated logarithmic
            sampling interval.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>sampling_scale</name>
        <version_id>1.0</version_id>
        <local_identifier>sampling_scale</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The sampling_scale attribute indicates the type of scale that applies to the 
            sample interval increments.  It must have a value of either Linear or Logarithmic.
        </definition>
        <DD_Value_Domain>
            <!--
                A General Note about Permissible Values:
                ========================================
                LDDTool uses the information from <DD_Permissible_Value> to create Schematron Rules
                to enforce the constraint.  There may be cases where you want an attribute with
                a single name that you are defining to have different permissible value lists in 
                different contexts (as pds:reference_type and pds:local_reference_type do).  
                Consider defining attributes with different names anyway - it's much cleaner and
                ensures complete documentation.
                
                If you absolutely HAVE to have the same name in all cases, then to avoid some of 
                the subtle problems that can arise in that case, your most stable option is to NOT 
                use <DD_Permissible_Value> classes to define the values, but rather to write 
                <DD_Rule> classes for each context to directly define the permitted values in each 
                specific context. 
                
                In that case, make sure the meanings of the values are documented somewhere users
                can find them when needed - talk to your PDS consultant on the options for that.
            -->
            <enumeration_flag>true</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
            <DD_Permissible_Value>
                <value>Linear</value>
                <value_meaning>The sampling intervals are linear with respect to the physical values they represent.</value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>Logarithmic</value>
                <value_meaning>The sampling values are logarithms of the physical values they represent.</value_meaning>
            </DD_Permissible_Value>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>solar_analog_star_name</name>
        <version_id>1.0</version_id>
        <local_identifier>solar_analog_star_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The solar_analog_star_name attribute provides a name in a standard format (i.e., one
            that is recognized by the SIMBAD system) for the solar analog star used to reduce
            the raw spectral data to the reflectance units presented in this spectrum.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>UTF8_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>spectral_bin_type</name>
        <version_id>1.0</version_id>
        <local_identifier>spectral_bin_type</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The spectral_bin_type attribute contains one of a defined set of values that indicates the
            binned sampling parameter type (frequency, wavelength, or wavenumber) of the spectrum.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>true</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
            <DD_Permissible_Value>
                <value>frequency</value>
                <value_meaning>
                    The spectrum is sampled in the frequency domain, and all binning parameters will be
                    in frequency units.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>wavelength</value>
                <value_meaning>
                    The spectrum is sampled in the wavelength domain, and all binning parameters will 
                    be in length units.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>wavenumber</value>
                <value_meaning>
                    The spectrum is sampled in the wavenumber domain, and all binning parameters will be
                    in wavenumber units.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>energy</value>
                <value_meaning>
                    The spectrum is sampled in the energy domain, and all binning parameters will be in 
                    energy units.
                </value_meaning>
            </DD_Permissible_Value>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>spectrum_format</name>
        <version_id>1.0</version_id>
        <local_identifier>spectrum_format</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The spectrum_format attribute is required to define the specific 
            dimensionality of the structure or substructure that contains 
            the intensity values. 
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>true</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
            <DD_Permissible_Value>
                <value>1D</value>
                <value_meaning>
                    Linear spectrum - each row of the table contains the information
                    for one bin (one point) on the spectrum.  You must specify the
                    name of the field containing the intensity information.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>2D</value>
                <value_meaning>
                    The spectrum is presented as a 2D array - an image.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>3D</value>
                <value_meaning>
                   The spectra are presented as a 3D array, each plane containing
                   a 2D spectrum.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>Tabulated-Flat</value>
                <value_meaning>
                    The spectra are presented as a table in which each row contains 
                    a single spectrum, and the individual spectral points and related
                    parameters are each defined by separated Field definitions - that 
                    is, no Group_Field classes are used in defining the spectral data
                    format.  In this case, all Fields containing spectral data or bin
                    parameters must have field_number attributes.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>Tabulated-Parameter Groups</value>
                <value_meaning>
                    The spectra are presented as a table in which each row contains a
                    single spectrum, and Group_Field classes are used to define the
                    fields corresponding to the spectral values, bin centers, and bin
                    widths (if present).  Each Group_Field must contain only a single
                    parameter - in other words, the spectral values a stored contiguously
                    within the record, the bin centers are stored contiguously within the
                    record, etc.  In this case, the Group_Field classes containing the
                    spectral values, bin centers, and bin widths (when present) must 
                    contain only a single Field that is repeated.
                </value_meaning>
            </DD_Permissible_Value>
            <DD_Permissible_Value>
                <value>Tabulated-Point Group</value>
                <value_meaning>
                    The spectra are presented as a table in which each row contains a
                    single spectrum, and a single Group_Field class is used to define
                    the value and all related parameters at a single spectral point. In
                    this case, the same Group_Field class must contain the spectral value,
                    bin center, and bin width (when present) for each point in the 
                    spectrum.
                </value_meaning>
            </DD_Permissible_Value>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>value_field_name</name>
        <version_id>1.0</version_id>
        <local_identifier>value_field_name</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The value_field_name attribute is required for 1D (linear) spectra.
            1D spectra are presented as a table, where each row presents one 
            point in the spectrum.  This field must contain a string corresponding
            to the 'name' attribute of the table field that contains the 
            spectral value.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>value_field_number_list</name>
        <version_id>1.0</version_id>
        <local_identifier>value_field_number_list</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The value_field_number_list attribute is used only in the case
            spectra in the format "Tabulated-Flat", where each row of a 
            table contains a spectrum and the spectral points are defined
            as individual Fields - one Field defined for each point.  The
            format is a parenthesized, ordered list of the field_number
            values from the Field definitions that correspond to the 
            spectral values.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Short_String_Collapsed</value_data_type>
            <formation_rule>
                Data should be provided as a parenthesized list of integers
                separated by commas. For example: (1, 5, 9, 13, 17, 21, 25)
            </formation_rule>
            <pattern>\(\s*[0-9]+(\s*,\s*[0-9]+)*\s*\)</pattern>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>width_angle</name>
        <version_id>1.0</version_id>
        <local_identifier>width_angle</local_identifier>
        <nillable_flag>true</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The width_angle is the angle subtended on the sky by the short
            dimension of a simple slit.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Angle</unit_of_measure_type>
            <specified_unit_id>deg</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <!-- Attributes with units in their tag names
    
         We need one form of these for each type of spectral unit for each of these attributes.
    -->

    <!-- Bin Width -->
    
    <DD_Attribute>
        <name>bin_width_energy</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_width_energy</local_identifier>
        <nillable_flag>true</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_width_energy attribute provides the width of a bin
            along a spectral axis in a spectral object, in energy units.
            The method used to calculate the width must be specified using the
            bin_profile_description attribute.
            
            This attribute can be set to 'nil' if bin widths are unknown.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Energy</unit_of_measure_type>
            <specified_unit_id>eV</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>bin_width_frequency</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_width_frequency</local_identifier>
        <nillable_flag>true</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_width_frequency attribute provides the width of a bin
            along a spectral axis in a spectral object, in frequency units.
            The method used to calculate the width must be specified using the
            bin_profile_description attribute.
            
            This attribute can be set to 'nil' if bin widths are unknown.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Frequency</unit_of_measure_type>
            <specified_unit_id>Hz</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>bin_width_wavelength</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_width_wavelength</local_identifier>
        <nillable_flag>true</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_width_wavelength attribute provides the width of a bin
            along a spectral axis in a spectral object, in wavelength units.
            The method used to calculate the width must be specified using the
            bin_profile_description attribute.
            
            This attribute can be set to 'nil' if bin widths are unknown.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Length</unit_of_measure_type>
            <specified_unit_id>m</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>bin_width_wavenumber</name>
        <version_id>1.0</version_id>
        <local_identifier>bin_width_wavenumber</local_identifier>
        <nillable_flag>true</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The bin_width_wavenumber attribute provides the width of a bin
            along a spectral axis in a spectral object, in wavenumber units.
            The method used to calculate the width must be specified using the
            bin_profile_description attribute.
            
            This attribute can be set to 'nil' if bin widths are unknown.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Wavenumber</unit_of_measure_type>
            <specified_unit_id>1/cm</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <!-- Bin Center -->
    
    <DD_Attribute>
        <name>center_energy</name>
        <version_id>1.0</version_id>
        <local_identifier>center_energy</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The center_energy attribute provides the value at the center of a bin 
            along the band axis of a spectral data object. When describing data from a
            spectrometer, the value corresponds to the peak of the response function 
            for a particular detector and/or grating.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Energy</unit_of_measure_type>
            <specified_unit_id>eV</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>center_frequency</name>
        <version_id>1.0</version_id>
        <local_identifier>center_frequency</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The center_frequency attribute provides the value at the center of a bin 
            along the band axis of a spectral data object. When describing data from a
            spectrometer, the value corresponds to the peak of the response function 
            for a particular detector and/or grating.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Frequency</unit_of_measure_type>
            <specified_unit_id>Hz</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>center_wavelength</name>
        <version_id>1.0</version_id>
        <local_identifier>center_wavelength</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The center_wavelength attribute provides the value at the center of a bin 
            along the band axis of a spectral data object. When describing data from a
            spectrometer, the value corresponds to the peak of the response function 
            for a particular detector and/or grating.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Length</unit_of_measure_type>
            <specified_unit_id>m</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>center_wavenumber</name>
        <version_id>1.0</version_id>
        <local_identifier>center_wavenumber</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The center_wavenumber attribute provides the value at the center of a bin 
            along the band axis of a spectral data object. When describing data from a
            spectrometer, the value corresponds to the peak of the response function 
            for a particular detector and/or grating.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Wavenumber</unit_of_measure_type>
            <specified_unit_id>1/cm</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <!-- First Bin Center  -->
    
    <DD_Attribute>
        <name>first_center_energy</name>
        <version_id>1.0</version_id>
        <local_identifier>first_center_energy</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The first_center_energy attribute provides the value at the
            center of the first bin along the spectral axis of a spectral data
            object in energy units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Energy</unit_of_measure_type>
            <specified_unit_id>eV</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>first_center_frequency</name>
        <version_id>1.0</version_id>
        <local_identifier>first_center_frequency</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The first_center_frequency attribute provides the value at the
            center of the first bin along the spectral axis of a spectral data
            object in frequency units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Frequency</unit_of_measure_type>
            <specified_unit_id>Hz</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>first_center_wavelength</name>
        <version_id>1.0</version_id>
        <local_identifier>first_center_wavelength</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The first_center_wavelength attribute provides the value at the
            center of the first bin along the spectral axis of a spectral data
            object in wavelength units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Length</unit_of_measure_type>
            <specified_unit_id>m</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>first_center_wavenumber</name>
        <version_id>1.0</version_id>
        <local_identifier>first_center_wavenumber</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The first_center_wavenumber attribute provides the value at the
            center of the first bin along the spectral axis of a spectral data
            object in wavenumber units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Wavenumber</unit_of_measure_type>
            <specified_unit_id>1/cm</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <!-- Last Bin Center  -->
    
    <DD_Attribute>
        <name>last_center_energy</name>
        <version_id>1.0</version_id>
        <local_identifier>last_center_energy</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The last_center_energy attribute provides the value at the
            center of the last bin along the spectral axis of a spectral data
            object in energy units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Energy</unit_of_measure_type>
            <specified_unit_id>eV</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>last_center_frequency</name>
        <version_id>1.0</version_id>
        <local_identifier>last_center_frequency</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The last_center_frequency attribute provides the value at the
            center of the last bin along the spectral axis of a spectral data
            object in frequency units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Frequency</unit_of_measure_type>
            <specified_unit_id>Hz</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>last_center_wavelength</name>
        <version_id>1.0</version_id>
        <local_identifier>last_center_wavelength</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The last_center_wavelength attribute provides the value at the
            center of the last bin along the spectral axis of a spectral data
            object in wavelength units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Length</unit_of_measure_type>
            <specified_unit_id>m</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>last_center_wavenumber</name>
        <version_id>1.0</version_id>
        <local_identifier>last_center_wavenumber</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The last_center_wavenumber attribute provides the value at the
            center of the last bin along the spectral axis of a spectral data
            object in wavenumber units.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Wavenumber</unit_of_measure_type>
            <specified_unit_id>1/cm</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <!-- Sampling Interval -->
    
    <DD_Attribute>
        <name>sampling_interval_energy</name>
        <version_id>1.0</version_id>
        <local_identifier>sampling_interval_energy</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The sampling_interval_energy attribute provides the spacing of points, 
            in energy units, at which data are sampled and at which a value
            for an instrument or data parameter is available. This sampling
            interval can be either the original (raw) sampling or the result of
            some resampling process.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Energy</unit_of_measure_type>
            <specified_unit_id>eV</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>sampling_interval_frequency</name>
        <version_id>1.0</version_id>
        <local_identifier>sampling_interval_frequency</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The sampling_interval_frequency attribute provides the spacing of points,
            in frequency units, at which data are sampled and at which a value
            for an instrument or data parameter is available. This sampling
            interval can be either the original (raw) sampling or the result of
            some resampling process.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Frequency</unit_of_measure_type>
            <specified_unit_id>Hz</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>sampling_interval_wavelength</name>
        <version_id>1.0</version_id>
        <local_identifier>sampling_interval_wavelength</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The sampling_interval_wavelength attribute provides the spacing of points,
            in wavelength units, at which data are sampled and at which a value
            for an instrument or data parameter is available. This sampling
            interval can be either the original (raw) sampling or the result of
            some resampling process.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Length</unit_of_measure_type>
            <specified_unit_id>m</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>sampling_interval_wavenumber</name>
        <version_id>1.0</version_id>
        <local_identifier>sampling_interval_wavenumber</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The sampling_interval_wavelength attribute provides the spacing of points,
            in wavenumber units, at which data are sampled and at which a value
            for an instrument or data parameter is available. This sampling
            interval can be either the original (raw) sampling or the result of
            some resampling process.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Wavenumber</unit_of_measure_type>
            <specified_unit_id>1/cm</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <!-- Spectral Resolution Limit -->
    
    <DD_Attribute>
        <name>resolution_limit_energy</name>
        <version_id>1.0</version_id>
        <local_identifier>resolution_limit_energy</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The resolution_limit_energy is the smallest possible distinguishable 
            interval in energy for the instrument.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Energy</unit_of_measure_type>
            <specified_unit_id>eV</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>
    
    <DD_Attribute>
        <name>resolution_limit_frequency</name>
        <version_id>1.0</version_id>
        <local_identifier>resolution_limit_frequency</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The resolution_limit_frequency is the smallest possible distinguishable 
            interval in frequency for the instrument.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Frequency</unit_of_measure_type>
            <specified_unit_id>Hz</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>resolution_limit_wavelength</name>
        <version_id>1.0</version_id>
        <local_identifier>resolution_limit_wavelength</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The resolution_limit_wavelength is the smallest possible distinguishable 
            interval in wavelengths for the instrument.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Length</unit_of_measure_type>
            <specified_unit_id>m</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>

    <DD_Attribute>
        <name>resolution_limit_wavenumber</name>
        <version_id>1.0</version_id>
        <local_identifier>resolution_limit_wavenumber</local_identifier>
        <nillable_flag>false</nillable_flag>
        <submitter_name>ACR</submitter_name>
        <definition>
            The resolution_limit_wavenumber is the smallest possible distinguishable
            interval in wavenumber for the instrument.
        </definition>
        <DD_Value_Domain>
            <enumeration_flag>false</enumeration_flag>
            <value_data_type>ASCII_Real</value_data_type>
            <minimum_value>5.0e-324</minimum_value>
            <unit_of_measure_type>Units_of_Wavenumber</unit_of_measure_type>
            <specified_unit_id>1/cm</specified_unit_id>
        </DD_Value_Domain>
    </DD_Attribute>


    <!-- ******************************************************************************************** -->

    <!-- Classes -->

    <!--
        Dictionary Preparation Hint: Really, avoid "TBD"!
        =================================================
        While <definition> values for classes are maybe not as critical as those for attributes,
        they are a major help to people trying to use your dictionary classes, and also may be
        needed by users down the road trying to understand what's going on in labels using the
        classes.  So avoid "TBD" here as well - it's good practice.
    -->

    <!--
        Dictionary Preparation Hint: Class Content Order
        ================================================
        Outside of "XSChoice" lists, where order isn't significant anyway, LDDTool will organize
        the content of each <DD_Class> in the same order in which you include the <DD_Association>
        classes.  It's worth giving this some thought - putting content in an order that seems 
        logical to users is an aid to understanding and can also help promote completeness on
        the design side.
    -->

    <!-- Filter -->

    <DD_Class>
        <name>Filter</name>
        <version_id>1.0</version_id>
        <local_identifier>Filter</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Filter class identifies the filter associated
            with a specific band or bin along a spectral axis in an Array
            object.  The filter may be identified by either name, identifier,
            or number or some combination of these.
        </definition>

        <DD_Association>
            <identifier_reference>filter_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <!--
                <minumum_occurrences> of zero means this attribute is optional
                in the class.
            -->
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>filter_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Field of View Description Subclasses -->

    <DD_Class>
        <name>Circular_FOV</name>
        <version_id>1.0</version_id>
        <local_identifier>Circular_FOV</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Circular_FOV class contains attributes to describe a circular 
            aperture/field of view.
        </definition>

        <DD_Association>
            <identifier_reference>diameter_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Rectangular_FOV</name>
        <version_id>1.0</version_id>
        <local_identifier>Rectangular_FOV</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            This class is used to describe a rectangular (i.e., slit) aperture.
        </definition>

        <DD_Association>
            <identifier_reference>width_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>length_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>celestial_north_position_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>body_positive_pole_position_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>    
    </DD_Class>

    <DD_Class>
        <name>Complex_FOV</name>
        <version_id>1.0</version_id>
        <local_identifier>Complex_FOV</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Complex_FOV class is used for apertures (slits) that are not
            either circular or a simple rectangular shape.
        </definition>

        <!--
            Note that this class re-uses attributes that are also included in
            the previous class.  The field name is the same in both places,
            and the definition is equally applicable.
            
            If the definition were not equally applicable, then I would have
            defined two different keywords that, because of the constraints
            in dictionary creation, would have to have unique field names as
            well.  Writing contingent definitions ("in this context it means 
            'A'; in that context 'B') is a good way to get your dictionary
            to fail peer review (Yes, your dictionary will be included in the
            external peer review!).
        -->

        <DD_Association>
            <identifier_reference>width_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>*</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>length_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>*</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>celestial_north_position_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>body_positive_pole_position_angle</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>    
    </DD_Class>

    <!-- Bin_Center_Lookup -->

    <DD_Class>
        <name>Bin_Center_Lookup</name>
        <version_id>1.0</version_id>
        <local_identifier>Bin_Center_Lookup</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Center_Lookup class provides a link to a map or list of bin center 
            values - either to a field in a spectral table, or to a distinct data object
            that is part of the same product, or to a separate PDS product containing 
            the information.
        </definition>

        <DD_Association>
            <identifier_reference>bin_center_field_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>bin_center_field_number_list</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <!--
            This class uses the pds:Local_Internal_reference class to link to a data
            object elsewhere in the same label; and the pds:Internal_Reference class
            to link to a data product somewhere else in the PDS archive.  In both
            cases, the dictionary writer who uses the pds: classes also needs to 
            define at least one <pds:reference_type> or <pds:local_reference_type>
            value specific to this context.  See the extended "Dictionary Preparation
            Hint" on the subject at the top of the DD_Rule section of this file, below.
            
            !!! This is a VERY easy thing to forget to do.  I recommend you IMMEDIATELY
            !!! create the <DD_Rule> for the reference type value every time you include
            !!! one of these pds: classes in one of your classes.  Happily, these rules
            !!! are usually among the easiest to formulate.
        -->

        <DD_Association>
            <identifier_reference>pds.Local_Internal_Reference</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>pds.Internal_Reference</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Bin_Width_Constant -->

    <DD_Class>
        <name>Bin_Width_Constant</name>
        <version_id>1.0</version_id>
        <local_identifier>Bin_Width_Constant</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Width_Constant class is used inside a Bin_Width_Lookup class
            for those cases where the bin width is either not well known or unknown.
            It provides a way to specify a nominal constant width or indicate that
            there is no available information about the bin width.  If the bin width 
            is completely unknown, use the appropriate bin_width attribute for the
            spectral type (frequency, wavelength, wavenumber, or energy), and indicate
            that it is nil, with a reason of "unknown".
            
            When this class is used, a full explanation of the situation should be 
            provided by the bin_width_desc attribute of the parent class.
        </definition>

        <DD_Association>
            <identifier_reference>XSChoice#</identifier_reference>
            <identifier_reference>bin_width_energy</identifier_reference>
            <identifier_reference>bin_width_frequency</identifier_reference>
            <identifier_reference>bin_width_wavelength</identifier_reference>
            <identifier_reference>bin_width_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>
    
    <!-- Bin_Width_Lookup -->

    <DD_Class>
        <name>Bin_Width_Lookup</name>
        <version_id>1.0</version_id>
        <local_identifier>Bin_Width_Lookup</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Width_Lookup class provides a link to a map or list of bin width 
            values - either to a field in a spectral table, or to a distinct data object
            that is part of the same product, or to a separate PDS product containing 
            the information.
        </definition>

        <DD_Association>
            <identifier_reference>bin_width_field_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>bin_width_field_number_list</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>pds.Local_Internal_Reference</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>pds.Internal_Reference</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Spectral_Lookup -->

    <DD_Class>
        <name>Spectral_Lookup</name>
        <version_id>3.0</version_id>
        <local_identifier>Spectral_Lookup</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Spectral_Lookup class references either specific Fields included
            in a spectral table (for 1D and tabulated spectra), or a 2-dimensional 
            lookup map providing spectral characteristics for a corresponding 
            spectral Array object.  In the latter case, the referenced lookup map 
            may either be to the referencing product, or an external stand-alone 
            product.
        </definition>
        
        <DD_Association>
            <identifier_reference>Bin_Center_Lookup</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>XSChoice#</identifier_reference>
            <identifier_reference>Bin_Width_Lookup</identifier_reference>
            <identifier_reference>Bin_Width_Constant</identifier_reference> <!-- Added 2019-07-29 -->
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Axis Bin Set by unit type -->
    
    <DD_Class>
        <name>Axis_Bin_Set_Energy</name>
        <version_id>1.0</version_id>
        <local_identifier>Axis_Bin_Set_Energy</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Axis_Bin_Set_* classes describe the spectral characteristics of
            each band along the spectral dimension of the data object.  This
            will be a literal "axis" in the case of 2D and 3D spectral arrays,
            or the "Row" axis of a spectral table (each row is a spectral bin),
            or the "Field" axis of table containing one spectrum per row.
            
            These classes are used in cases where the spectral information is not
            uniform along the spectral dimension.
        </definition>
        
        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>Bin_Energy</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>unbounded</maximum_occurrences>
        </DD_Association>
    </DD_Class>
    
    <DD_Class>
        <name>Axis_Bin_Set_Frequency</name>
        <version_id>2.1</version_id>
        <local_identifier>Axis_Bin_Set_Frequency</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Axis_Bin_Set_* classes describe the spectral characteristics of
            each band along the spectral dimension of the data object.  This
            will be a literal "axis" in the case of 2D and 3D spectral arrays,
            or the "Row" axis of a spectral table (each row is a spectral bin),
            or the "Field" axis of table containing one spectrum per row.

            These classes are used in cases where the spectral information is not
            uniform along the spectral dimension.
        </definition>

        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Bin_Frequency</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>unbounded</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Axis_Bin_Set_Wavelength</name>
        <version_id>2.1</version_id>
        <local_identifier>Axis_Bin_Set_Wavelength</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Axis_Bin_Set_* classes describe the spectral characteristics of
            each band along the spectral dimension of the data object.  This
            will be a literal "axis" in the case of 2D and 3D spectral arrays,
            or the "Row" axis of a spectral table (each row is a spectral bin),
            or the "Field" axis of table containing one spectrum per row.
            
            These classes are used in cases where the spectral information is not
            uniform along the spectral dimension.
        </definition>

        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Bin_Wavelength</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>unbounded</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Axis_Bin_Set_Wavenumber</name>
        <version_id>2.1</version_id>
        <local_identifier>Axis_Bin_Set_Wavenumber</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Axis_Bin_Set_* classes describe the spectral characteristics of
            each band along the spectral dimension of the data object.  This
            will be a literal "axis" in the case of 2D and 3D spectral arrays,
            or the "Row" axis of a spectral table (each row is a spectral bin),
            or the "Field" axis of table containing one spectrum per row.
            
            These classes are used in cases where the spectral information is not
            uniform along the spectral dimension.
        </definition>

        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Bin_Wavenumber</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>unbounded</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Uniformly_Sampled by unit type -->
    
    <DD_Class>
        <name>Uniformly_Sampled_Energy</name>
        <version_id>1.0</version_id>
        <local_identifier>Uniformly_Sampled_Energy</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Uniformly_Sampled_Energy class provides attributes
            describing the spectral characteristics of a named axis of an
            Array object or the rows or fields of a Table object, in cases 
            where the spectral sampling interval is regular and the sampling 
            parameters are in energy units.
        </definition>
        
        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>sampling_interval_energy</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>sampling_scale</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>sampling_base</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>bin_width_energy</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>first_center_energy</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>last_center_energy</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>
    
    <DD_Class>
        <name>Uniformly_Sampled_Frequency</name>
        <version_id>2.0</version_id>
        <local_identifier>Uniformly_Sampled_Frequency</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Uniformly_Sampled_Frequency class provides attributes
            describing the spectral characteristics of a named axis of an
            Array object or the rows or fields of a Table object, in cases 
            where the spectral sampling interval is regular and the sampling 
            parameters are in frequency units.
        </definition>

        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_interval_frequency</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_scale</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_base</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>bin_width_frequency</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>first_center_frequency</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>last_center_frequency</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Uniformly_Sampled_Wavelength</name>
        <version_id>2.0</version_id>
        <local_identifier>Uniformly_Sampled_Wavelength</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Uniformly_Sampled_Wavelength class provides attributes
            describing the spectral characteristics of a named axis of an
            Array object or the rows or fields of a Table object, in cases 
            where the spectral sampling interval is regular and the sampling 
            parameters are in wavelength units.
        </definition>

        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_interval_wavelength</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_scale</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_base</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>bin_width_wavelength</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>first_center_wavelength</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>last_center_wavelength</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Uniformly_Sampled_Wavenumber</name>
        <version_id>2.0</version_id>
        <local_identifier>Uniformly_Sampled_Wavenumber</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Uniformly_Sampled_Wavenumber class provides attributes
            describing the spectral characteristics of a named axis of an
            Array object or the rows or fields of a Table object, in cases 
            where the spectral sampling interval is regular and the sampling 
            parameters are in wavenumber units.
        </definition>

        <DD_Association>
            <identifier_reference>axis_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_interval_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_scale</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>sampling_base</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>bin_width_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>first_center_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>last_center_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Bin by unit type -->
    
    <DD_Class>
        <name>Bin_Energy</name>
        <version_id>1.0</version_id>
        <local_identifier>Bin_Energy</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Energy class specifies the characteristics of an
            individual bin along a spectral or other binned axis in an Array
            object, in units of energy.
        </definition>
        
        <DD_Association>
            <identifier_reference>bin_sequence_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>center_energy</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>bin_width_energy</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>detector_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>grating_position</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>Filter</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>
    
    <DD_Class>
        <name>Bin_Frequency</name>
        <version_id>2.0</version_id>
        <local_identifier>Bin_Frequency</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Frequency class specifies the characteristics of an
            individual bin along a spectral or other binned axis in an Array
            object, in units of frequency.
        </definition>

        <DD_Association>
            <identifier_reference>bin_sequence_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>center_frequency</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>bin_width_frequency</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>detector_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>grating_position</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Filter</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Bin_Wavelength</name>
        <version_id>2.0</version_id>
        <local_identifier>Bin_Wavelength</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Wavelength class specifies the characteristics of an
            individual bin along a spectral or other binned axis in an Array
            object, in units of wavelength.
        </definition>

        <DD_Association>
            <identifier_reference>bin_sequence_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>center_wavelength</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>bin_width_wavelength</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>detector_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>grating_position</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>Filter</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <DD_Class>
        <name>Bin_Wavenumber</name>
        <version_id>2.0</version_id>
        <local_identifier>Bin_Wavenumber</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Bin_Wavenumber class specifies the characteristics of an
            individual bin along a spectral or other binned axis in an Array
            object, in units of wavenumber.
        </definition>

        <DD_Association>
            <identifier_reference>bin_sequence_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>center_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>bin_width_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>detector_number</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>grating_position</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>Filter</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Bin Description  -->
    <!--
         This class groups all the bin description options for the
         purpose of validation - ensuring that exactly one is present
         via the max/min occurrences constraint on the XSChoice list.
    -->

    <DD_Class>
        <name>Bin_Description</name>
        <version_id>2.0</version_id>
        <local_identifier>Bin_Description</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            This class groups the various bin description options, 
            allowing a user to choose one.
        </definition>

        <DD_Association>
            <identifier_reference>bin_profile_description</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>XSChoice#</identifier_reference>
            <!-- Remove 2019-07-29 from here to Spectral_Lookup
            <identifier_reference>Bin_Width_Constant</identifier_reference>
            -->
            <identifier_reference>Uniformly_Sampled_Frequency</identifier_reference>
            <identifier_reference>Uniformly_Sampled_Wavelength</identifier_reference>
            <identifier_reference>Uniformly_Sampled_Wavenumber</identifier_reference>
            <identifier_reference>Axis_Bin_Set_Frequency</identifier_reference>
            <identifier_reference>Axis_Bin_Set_Wavelength</identifier_reference>
            <identifier_reference>Axis_Bin_Set_Wavenumber</identifier_reference>
            <identifier_reference>Spectral_Lookup</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

    </DD_Class>

    <!-- Observation Parameters -->

    <DD_Class>
        <name>Observation_Parameters</name>
        <version_id>1.0</version_id>
        <local_identifier>Observation_Parameters</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Observation_Parameters class collects various values related to
            the observational circumstances.  In general, this class should be
            present, and all parameters applicable to the situation should be
            included, even though optional.  In some complex cases or for 
            high-level derived products this class may not be applicable, in 
            which case it may be omitted.
            
            Use the 'comment' attribute to describe any special circumstances
            users should be aware of.
        </definition>

        <DD_Association>
            <identifier_reference>number_of_exposures</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>net_integration_time</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>XSChoice#</identifier_reference>
            <identifier_reference>resolution_limit_energy</identifier_reference>
            <identifier_reference>resolution_limit_frequency</identifier_reference>
            <identifier_reference>resolution_limit_wavelength</identifier_reference>
            <identifier_reference>resolution_limit_wavenumber</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>solar_analog_star_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>*</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>absolute_calibration_star_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>*</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>comment</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- FoV Description -->

    <DD_Class>
        <name>Field_of_View</name>
        <version_id>1.0</version_id>
        <local_identifier>Field_of_View</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Field_of_View class is used to describe the field of view corresponding
            to the spectral data object.  This class should describe the aperture or slit
            used in making the spectral observation, when applicable, as opposed to the 
            theoretical full field of view of a telescope or boresight (which should be 
            defined in a Geometry Dictionary class).
        </definition>

        <DD_Association>
            <identifier_reference>description</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>XSChoice#</identifier_reference>
            <identifier_reference>Circular_FOV</identifier_reference>
            <identifier_reference>Rectangular_FOV</identifier_reference>
            <identifier_reference>Complex_FOV</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>pds.Internal_Reference</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- Wrapper Class: Spectral_Characteristics -->

    <DD_Class>
        <name>Spectral_Characteristics</name>
        <version_id>2.0</version_id>
        <local_identifier>Spectral_Characteristics</local_identifier>
        <submitter_name>ACR</submitter_name>
        <definition>
            The Spectral_Characteristics class provides information about the 
            spectral characteristics of a 1D, 2D, or 3D spectral data object.
            It is note used for tabulated spectra - tables in which each row
        </definition>
        <!--
            Dictionary Preparation Hint - Wrapper Classes as Entry Points
            =============================================================
            Because this is the wrapper class - the entry point for everything else
            and the class I want data preparers to always use in their labels - this
            is the ONLY <DD_Class> that contains <element_flag>, and it is set to 
            "true".  This creates a visible <sp:Spectral_Characteristics> XML element
            that can be used in PDS4 product labels.
            
            Including the flag here precludes needing any special arguments to  
            LDDTool on the command line, and also ensures I don't expose a bunch
            of elements I don't want users to include in their labels ad hoc.  
            
            Some dictionaries might define more than one entry point - that's fine 
            if it makes sense in your context.  Kane kati logiko.
        -->
        <element_flag>true</element_flag>

        <DD_Association>
            <identifier_reference>pds.Local_Internal_Reference</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>description</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>spectrum_format</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>value_field_name</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>value_field_number_list</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
        
        <DD_Association>
            <identifier_reference>spectral_bin_type</identifier_reference>
            <reference_type>attribute_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Observation_Parameters</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>0</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Field_of_View</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>

        <DD_Association>
            <identifier_reference>Bin_Description</identifier_reference>
            <reference_type>component_of</reference_type>
            <minimum_occurrences>1</minimum_occurrences>
            <maximum_occurrences>1</maximum_occurrences>
        </DD_Association>
    </DD_Class>

    <!-- ************************************************************************************** -->

    <!-- Rules -->

    <!--
        Dictionary Preparation Hint: Namespaces in Schematron Rules
        ===========================================================
        Schematron is namespace-obsessive.  Every single attribute and class name MUST have 
        a namespace explicitly associated with it, regardless of how you've set up your 
        dictionary or product label.  Use the official namespace abbreviation strings for 
        this and LDDTool will handle the Schematron setup for you.  But you will need to
        use prefixes for EVERYTHING you're testing - in the context, in the tests,
        everywhere.  It's really easy to forget them, and hard to tell when they're missing
        because as far as Schematron is concerned it is also valid for an attribute to have
        no namespace.  This is a big part of why rigorous testing is critical.  
        
        Speaking of...
    -->

    <!--
        Dictionary Preparation Hint: Test, Test, Test Schematron Rules
        ==============================================================
        Always create some sort of dummy label to test Schematron rules, and test them as
        you write them.  This is critical because of the nature of Schematron processing,
        which is based on XSLT (stylesheet translation) processing.  For every rule you 
        write, there are three possible processing outcomes:
        
          1. The rule fires (is executed) and succeeds.
          2. The rule fires and fails.
          3. The rule never fires.
          
        Only one of these cases will produce a message, depending on how you coded the 
        rule.  If you do not test the case where the rule should produce a message, 
        you don't know if the rule ever fired.  So when you code or change a rule, add
        lines in your test file that should both succeed and fail.  Only if both of
        these produce the expected result (one produces a message and the other 
        doesn't, as desired) can you be confident you've coded the test correctly.
        
        (This is where a validating editor can save you a LOT of time over running and
        re-running Validate on a single label.)
    -->

    <!--
        Dictionary Preparation Hint: Developing Schematron Rules
        ========================================================
        If you're not already fluent in XPath 2.0, writing Schematron rule tests can be 
        very frustrating.  VERY frustrating.  Like "Now I have to buy a new coffee 
        mug" frustrating.  If you want to do anything more than just cut & paste on
        the simplest rules, here's what I recommend:
        
          o Learn the XPath 2.0 basics from a tutorial website or book.  Doesn't take 
            long, maybe an hour or two if you're a completionist.
          o Find yourself a reference manual or bookmark a reference website site for 
            XPath functions and syntax. (I used a PDF version of "XSLT 2.0 and XPath 
            2.0 - 4th Edition" by Michael Kay as my reference.  Poorly edited - 
            1300+ chatty pages - but everything I needed was in there somewhere.)
          o Take a stab at coding your new rule and run LDDTool to get a Schematron file
            to work with.  Syntax errors in rules can't be detected by LDDTool, so 
            even flagrant errors won't stop the production of the output file - though
            the Schematron file itself (if you look at it in a validating editor, for
            example) may contain moderately serious syntax errors.
          o Test and trouble-shoot the rules by directly editing the Schematron file
            and checking the result with your test label. (Glad you wrote one now,
            aren't you?)
          o When you've got the rules working from the Schematron the way you want
            them to, cut & paste the various parts of the working rule back into your 
            <DD_Rule> class.
          o Run LDDTool again and you should now have a Schematron rule working 
            just the way you want it to.
          o Test it again like it's a twice-convicted perjurer.
          o Rejoice briefly and move on to the next rule.
            
        One thing to be wary of: Schematron is XML, so characters like '<', '>', 
        and '&' are problematic in a Schematron test or message.  Typically you 
        use the character entities "&lt;", "&gt;" and "&amp;" to avoid trouble in 
        XML files, but since the strings you're coding here for tests are parsed as 
        XML content before being transferred to the output also-XML Schematron file,
        just using the entities doesn't do the job.  Instead, you'll need to code 
        "&amp;lt;", "&amp;gt;", and "&amp;amp" to get the desired entities into your
        tests and messages when you need those characters.  Really.  No, seriously.
        
        Search on "&amp;gt;" to see an example of this in action, below.
    -->
    
    <!--
        A Note on Schematron Jargon
        ===========================
        Schematron processing starts by parsing the label file it's validating into a 
        document tree, where any tag (e.g., "<name>") is called a "node", generically.
        XPath tests navigate through this tree both by tracing relationships between
        and among nodes (parent, child, sibling, etc.), and by accessing the values
        associated with nodes that correspond to PDS attributes.
        
        I'll probably drop into "node" jargon in some of the following discussions.  It
        may pay to skim through that XPath tutorial before proceeding...
    -->


    <!-- sp:Spectral Characteristics/pds:Local_Internal_Reference... -->

    <!--
        Dictionary Preparation Hint: pds:reference_type and pds:local_reference_type Values
        ===================================================================================
        PDS defines specific, contextual <reference_type> and <local_reference_type> values 
        for every instance in which they appear.  They are required to be present, and when you 
        make use of the <pds:Internal_Reference> and <pds:Local_Internal_Reference> classes you
        must, must, MUST define values for every context in which you will need them.  There
        is no way that can be checked by schematic validation, though, so it's up to the 
        dictionary writer to a) remember to do it; and b) not do it sloppily.
        
        Many local dictionary preparers will be lucky - they will use the Reference classes
        either once or not at all; or there really will be only one reference type value
        that is appropriate for all the uses of the reference class.  In those cases you
        can define a single <DD_Rule> on the "pds:Internal_Reference" or 
        "pds:Local_Internal_Reference" context and you're covered.
        
        More complex dictionaries, like this one, have different type values depending on
        what sort of thing is being referenced, and why the thing that's being referenced 
        is being referenced.  This requires a definition like the one below, which is 
        specific to an "sp:" namespace context (for comparison, see the rule defined farther 
        down on the sp:Bin_Center_Lookup use of the same pds:Local_Internal_Reference class).  
        If all the values were combined in a single rule on the pds:Local_Internal_Reference
        globally, then the wrong type value could be used in both places and still pass 
        validation.  That would be bad.
        
        Why does it matter?  The reference_type values serve two purposes - first, they 
        give a human reader a very broad indication of why the thing previously mentioned 
        is being referenced at this particular point.  Second, they can be used by software
        to automatically offer, link to, and retrieve the associated data or product in a
        search or processing environment.  Maybe this will never happen, but if you take 
        a few minutes to think about the relationships and code the values accordingly here,
        you enable that sort of use with minutes of effort that never has to be repeated.  
        Trying to retrofit values after the fact would likely take days, and quiet possibly 
        weeks, of analysis, coding, and database updating effort.  So it's really a "good 
        citizen" type of issue for the archive community.
        
        I encourage you to be a good citizen.
    -->

    <DD_Rule>

        <!--
            This is actually a fairly complicated DD_Rule to start off with, so I'll give you a blow-by-blow.
            I'm defining values for pds:local_reference_type that are specific to the data structure of the
            spectrum, so that the information is immediately accessible to processing routines and human 
            readers.  Helps to keep things straight in a label containing more than one data object type.
            But in order to do this, I need to know what kind of data object is being pointed to by the 
            pds:local_internal_reference value - and then I need to make sure the right enumerated list
            value is being used for that object type.
        -->
        <local_identifier>sc_lir</local_identifier>
        <!-- 
            The <rule_context> defines when the test will be performed.  This test will be performed for 
            every instance of a Spectral_Characteristics class, in this case. 
        -->
        <rule_context>sp:Spectral_Characteristics/pds:Local_Internal_Reference</rule_context>
        <!-- 
            The next two lines define variables.  The first one is defined for my own reading convenience.  
            It contains the value of the <pds:local_identifier_reference> attribute.  This assignment 
            could have been folded into the next assignment if my screen were wider. 
        -->
        <rule_assign>name="objid" value="string(pds:local_identifier_reference)"</rule_assign>
        <!--
            This assignment ultimately returns the class name of the referenced data object, without the
            namespace abbreviation attached.
              local-name()                  returns the XML tag name of its argument without the namespace
              //parent::node()              checks every node that has a parent node (i.e., everything but document root)
              [pds:local_identifier=$objid] filters out all nodes from the '//parent::node()' list that don't have $objid 
                                            as the local_identifier value
              
            The end result is the variable $objtype being set to the class name of the object that
            has the given local identifer - so $objid will be something like "Array_2D_Spectrum" or
            "Table_Binary".
        -->
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <!--
            Dictionary Preparation Hint: Define All Context Rules at Once
            =============================================================
            The <DD_Rule_Statement> classes define specific tests I want to run in this context.  You can test 
            as many things as you like, but all tests for this context need to be defined here.  If you 
            accidentally reuse a context, LDDTool will happily produce two separate occurrences of the same 
            context in the output Schematron file.  THIS IS NOT AN ERROR as far as validation of the Schematron 
            file itself goes, but according to the Schematron processing model, only one of those sets of rules 
            will be checked. Schematron stops checking once it matchs the current node it's looking at to a 
            context and runs only the rules listed in that set. This is one of those mistakes that is very hard 
            to recognize unless you're specifically checking for it (by making sure ALL your defined rules are
            firing).
            
            Also, it's important to remember that ALL rules defined within a single <rule_context> set will be 
            applied when that context is matched.
        -->
        <DD_Rule_Statement>
            <!--
                Rule type:
                  "Assert" checks to see if the test is true and reports when it isn't. 
                  "Report" checks to see if the test is true and reports when it is.
                  
                I pretty much always use Assert.  The difference is entirely one of style.
            -->
            <rule_type>Assert</rule_type>
            <!--
                Here is the list of all possible valid standard values.  This check ensures that random
                text is not allowed, and closes logical holes that would otherwise be left in the next
                two rules.  Schematron is inherently list-based, so this test is checking whether
                the value of pds:local_reference is in the set of strings in parentheses.  Parentheses
                around a single string would be optional, but not wrong.
            -->
            <rule_test>pds:local_reference_type = ('spectral_characteristics_to_array_object', 'spectral_characteristics_to_table_object')</rule_test>
            <!--
                Because this is an Assert-type test, this message will be printed if the test fails.  
                Another aspect of "good citizenship" is making it easy for the user to see and correct
                what he did wrong, so including the full list of valid values for something like this
                is strongly recommended.
            -->
            <rule_message>sp:Spectral_Characteristics: The attribute pds:local_reference_type must be equal to either 'spectral_characteristics_to_array_object' or 'spectral_characteristics_to_table_object'.</rule_message>
            <!--
                This is an optional description field for your own use.  It is not propagated to the 
                Schematron or Schema files created.
            -->
            <rule_description> Sets the standard value for pds:local_reference_type in this context </rule_description>
        </DD_Rule_Statement>
        <!-- Same context - second rule... -->
        <DD_Rule_Statement>
            <!-- Also an assertion... -->
            <rule_type>Assert</rule_type>
            <!--
                This test is more complex.  For XPath (which is what this coding is), 'if' must by accompanied
                by both a 'then' and an 'else'.
                
                This test checks to see if the reference type is the value appropriate for arrays.  If 
                it is, then the $objtype value previously assigned is checked against the valid spectral
                array types to make sure the spectrum being described has the right sort of data 
                structure for what will follow.  If the object type is not a spectral array, the
                message is reported.  If it is, nothing is reported.   This check also helps to ensure 
                that Spectral data are identified by data object type, not just implied by other metadata 
                values.
                
                This could have been verified in a number of different ways in the final Spectral dictionary.
                This is one of the first tests I wrote, though, so it has remained.  I particularly like 
                the reference to the actual data object class in this case.
                
                The "true()" function (there is also a "false()" function) returns a boolean value of 'true'.
                The empty parentheses are required.  This ensures that if the local_reference_type check fails
                (i.e., we're not looking at an array type), no message is reported.
            -->
            <rule_test>if (pds:local_reference_type = ('spectral_characteristics_to_array_object')) then ($objtype = ('Array_2D_Spectrum', 'Array_3D_Spectrum')) else true()</rule_test>
            <rule_message>The Array-type object referenced by sp:Spectral_Characteristics must be either an Array_2D_Spectrum or an Array_3D_Spectrum.</rule_message>
            <rule_description> Ties the local_reference_type to a specific data object </rule_description>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <!-- The final assertion... -->
            <rule_type>Assert</rule_type>
            <!--
                This is the alternate case to the previous assertions - if the data aren't in an array,
                they must be in a table.  Since there is no specific Spectral table type defined, we
                merely check that either a Table_Character or Table_Binary is on the other end of the
                local reference.
                
                Because of the first rule which limits the type values, the array-check rule and
                this table-check rule don't need to worry about random values falling through the
                "if" tests.
            -->
            <rule_test>if (pds:local_reference_type = ('spectral_characteristics_to_table_object')) then ($objtype = ('Table_Character', 'Table_Binary', 'Table_Delimited')) else true()</rule_test>
            <rule_message>In sp:Spectral_Characteristics must reference either a Table_Character, Table_Binary, or Table_Delimited object when pds:local_reference_type is 'spectral_characteristics_to_table_object'.</rule_message>
            <rule_description> Ties the local_reference_type to a specific data object </rule_description>
        </DD_Rule_Statement>

        <!--
            You can find the resulting set of Schematron statements in the output Schematron file
            by searching for the <rule_context> value string above, i.e., 
            "sp:Spectral_Characteristics/pds:Local_Internal_Reference", in the Schematron file.
        -->
    </DD_Rule>

    <!-- sp:Spectral_Characteristics checks on sp:spectrum_format -->

    <DD_Rule>
        <local_identifier>frmt1d_field</local_identifier>
        <rule_context>sp:Spectral_Characteristics/sp:spectrum_format</rule_context>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <!-- sp:Spectral_Characteristics/sp:spectrum_format value must correspond to object type -->
        <!-- This takes a separate test for each value of sp:spectrum_format -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = 'Tabulated-Flat') then ($objtype = ('Table_Character','Table_Binary','Table_Delimited')) else true()</rule_test>
            <rule_message>sp:spectrum_format of 'Tabulated-Flat' must be used with a table-type object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = 'Tabulated-Parameter Groups') then ($objtype = ('Table_Character','Table_Binary','Table_Delimited')) else true()</rule_test>
            <rule_message>sp:spectrum_format of 'Tabulated-Parameter Groups' must be used with a table-type object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = 'Tabulated-Point Group') then ($objtype = ('Table_Character','Table_Binary','Table_Delimited')) else true()</rule_test>
            <rule_message>sp:spectrum_format of 'Tabulated-Point Group' must be used with a table-type object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = '1D') then ($objtype = ('Table_Character','Table_Binary','Table_Delimited')) else true()</rule_test>
            <rule_message>sp:spectrum_format of '1D' must be used with a table-type object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = '2D') then ($objtype = ('Array_2D_Spectrum')) else true()</rule_test>
            <rule_message>sp:spectrum_format of '2D' must be used with an Array_2D_Spectrum-type object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = '3D') then ($objtype = ('Array_3D_Spectrum')) else true()</rule_test>
            <rule_message>sp:spectrum_format of '3D' must be used with an Array_3D_Spectrum-type object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <!-- sp:Spectral_Characteristics/sp:spectrum_format of "1D", "Tabulated-Parameter Groups", and "Tabulated-Point Group" must come with field name -->
            <rule_type>Assert</rule_type>
            <!--
                This assertion is a "required or prohibited" check.  If the spectrum we're
                describing is one of three specific types, then the data preparer has to indicate 
                the name of the field in the table row (or Group_Field) that contains the measurement 
                via <value_field_name>.
                
                If this isn't a 1D or Tabulated-Grouped spectrum, then a value_field_name is prohibited.
                
                if (string(node()) = ('1D', 'Tabulated-Parameter Groups', 'Tabulated-Point Group')
                                              gets the value of the context node, converts it 
                                              to a string, and compares it to each item in the list.
                                              If it matches any of then, the result is "true".
                then (parent::node()/sp:value_field_name)
                                              the parent of the context node (i.e., this 
                                              Spectral_Characteristics class) must have a
                                              sp:value_field_name attribute.
                else not(parent::node()/sp:value_field_name)
                                              otherwise (the type isn't one of the listed types) it better not
            -->
            <rule_test>if (string(node()) = ('1D', 'Tabulated-Parameter Groups', 'Tabulated-Point Group')) then (parent::node()/sp:value_field_name) else not(parent::node()/sp:value_field_name)</rule_test>
            <rule_message>sp:value_field_name is required when sp:spectrum_format is '1D', 'Tabulated-Parameter Groups', or 'Tabulated-Point Group' and prohibited otherwise.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (string(node()) = ('Tabulated-Flat')) then (parent::node()/sp:value_field_number_list) else not(parent::node()/sp:value_field_number_list)</rule_test>
            <rule_message>The sp:value_field_number_list attribute is required, and may only be used, when sp:spectrum_format is 'Tabulated-Flat'.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:value_field_name must be present and unique in the associated spectrum object -->

    <DD_Rule>
        <!--
            This rule checks that when a value_field_name is used, not only is there a Table
            object containing a Field object with the value in the <name> attribute, but it
            also makes sure it's the same object that was identified by the 
            pds:local_identifier_reference at the top of the Spectral_Characteristics class 
            and that the name is unique within the table.
        -->
        <local_identifier>valfld_present</local_identifier>
        <rule_context>sp:Spectral_Characteristics/sp:value_field_name</rule_context>
        <rule_assign>name="valfield" value="string(node())"</rule_assign>
        <!-- Saves the string in <value_field_name> -->
        <!--
            As before, these lines retrieve the type of the data object being referenced.
            This is needed because the XPath the field name depends on the table type.
        -->
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <rule_assign>name="specform" value="string(ancestor::sp:Spectral_Characteristics/sp:spectrum_format)"</rule_assign>
        <!--
            Similarly to previous checks, "//parent::node()[pds:local_identifier=$objid]" selects the root of the
            referenced data object - in this case a specific Table_Character - by selecting the parent of the class
            that has an attribute called "pds:local_identifier" with a value equal to $objid.  The rest if the path 
            down to the <name> follows the '/' (note that "pds:" must be specified on every step of the way), and 
            then finally the value of the various "pds:name" attributes is compared to the $valfield, saved from the 
            reference.  The test succeeds if any one <pds:name> field in the selected Table_Character matches, and 
            fails if none does.  If the referenced object wasn't a Table_Character, "else true()" means no message 
            is displayed. 
        -->
        <!--
            There are two cases to check - 1D spectra and tabulated spectra involving groups.  Each of these pairs 
            must be repeated for the three kinds of tables - Character, Binary, and Delimited.
        -->
        <!-- Table_Character checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Character')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Field_Character/pds:name[data(.)=$valfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:value_field_name attribute must correspond to the name of exactly one Field_Character in the referenced Table_Character object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype = 'Table_Character')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Group_Field_Character/pds:Field_Character/pds:name[data(.)=$valfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:value_field_name attribute must correspond to the name of exactly one Field_Character inside a Group_Field_Character for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
        <!-- Table_Binary checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Binary')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Field_Binary/pds:name[data(.)=$valfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:value_field_name attribute must correspond to the name of exactly one Field_Binary in the referenced Table_Binary object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype = 'Table_Binary')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Group_Field_Binary/pds:Field_Binary/pds:name[data(.)=$valfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:value_field_name attribute must correspond to the name of exactly one Field_Binary inside a Group_Field_Binary for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
        <!-- Table_Delimited checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Delimited')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Field_Delimited/pds:name[data(.)=$valfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:value_field_name attribute must correspond to the name of exactly one Field_Delimited in the referenced Table_Delimited object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype='Table_Delimited')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Group_Field_Delimited/pds:Field_Delimited/pds:name[data(.)=$valfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:value_field_name attribute must correspond to the name of exactly one Field_Delimited inside a Group_Field_Delimited for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <!-- Tabulated-Flat value_field_number_list check -->
    
    <DD_Rule>
        <local_identifier>vallist_eu</local_identifier>
        
        <!--
            This is a very complex rule that requires some processing of the value retrieved from the label.  This rule checks that when the value_field_number_list attribute is used, each 
            number in the list corresponds to the value of a <field_number> attribute in a Field definition of the Table containing the (tabulated) spectra.  We can depend on the XSD part
            of the validation to ensure that the string syntax is correct (a parenthesized list of integers separated by commas), but we still need to get to the individual integers and
            make sure they match exactly one <field_number> in the table.
            
            Note that this test is necessary not only because <field_numbers> are not required - and if we're going to reference them they better be present - but also because even when 
            they are present, there are no checks in the core namespace to ensure that they are either unique or sequential,  So there are no safe, simplifying assumptions (like the 
            field_number corresponds to document occurence order) that we can make.
        -->
        <rule_context>sp:Spectral_Characteristics/sp:value_field_number_list</rule_context>
        <!-- This technique for finding the table being referenced is described above, in the value_field_name check. -->
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <!--
            These lines normalize whitespace in the value string, and then remove the parentheses (they were included purely for human impact - they're in the way here).
        -->
        <rule_assign>name="val" value="normalize-space(string())"</rule_assign>
        <rule_assign>name="numlist" value="substring($val,2,string-length($val)-2)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Character') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Field_Character/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <!--
                Here's what's happening in this complicated "then" clause:
                
                    (tokenize($numlist,'\s*,\s*')   turns the string value in $numlist into a sequence of string values, breaking on comma (optionally surrounded by whitespace)
                    every $n in ([sequence])        loops through each of the strings we just created - so each of the field_number values in our list
                    satisfies                       tests that for each $n, the following statement is true
                    count(...)=1                    All that code in the (), most of which should look familiar, finds Field_Character nodes from the table identified by $objid that also
                                                    have a <field_number> attribute with a value that is the same as $n.  There should only be one of these, so we count them and check.  If
                                                    the count is anything other than 1, the "satisfies" test fails and the error message is displayed.
            -->
            <rule_message>For Tabulated-Flat spectra, every value of sp:value_field_number_list must correspond to the value of a field_number attribute in a Field_Character definition.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Binary') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Field_Binary/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:value_field_number_list must correspond to the value of a field_number attribute in a Field_Binary definition.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Delimited') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Field_Delimited/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:value_field_number_list must correspond to the value of a field_number attribute in a Field_Delimited definition.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <!-- sp:Uniformly_Sampled_(unit_type) -->
    
    <DD_Rule>
        <!--
            This context has a number of rules to make sure that the appropriate type of classes are
            being used, and the references to information elsewhere in the label are resolvable.
            The specifics vary, but the techniques are the same as already seen.  They are used
            a lot in this dictionary because of the range of spectral types covered.  Consequently
            There is a DD_Rule for each spectral type of Uniformly_Sampled_* (energy, frequenct,
            wavelength, and wavenumber).
        -->
        <local_identifier>us_energy</local_identifier>
        <rule_context>sp:Uniformly_Sampled_Energy</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('energy')</rule_test>
            <rule_message>The sp:Uniformaly_Sampled_Energy may only be used when sp:spectral_bin_type is "energy".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Array_2D_Spectrum', 'Array_3D_Spectrum')) then (//parent::node()[pds:local_identifier=$objid]/pds:Axis_Array/pds:axis_name=sp:axis_name) else true()</rule_test>
            <rule_message>If the referenced object is an array, then sp:axis_name must correspond to the name attribute of one of the Array_Axis classes in that array object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Table_Character', 'Table_Binary', 'Table_Delimited')) then (sp:axis_name = ('Row','Field')) else true()</rule_test>
            <rule_message>Specify "Row" for a spectral table to indicate that the rows constitute uniformly sampled bins.
                Specify "Field" to indicate that each row contains a complete spectrum and the fields constitute uniformly sample bins.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale = 'Linear') then (not(sp:sampling_base)) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is forbidden if sp:sampling_scale is "Linear".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale ne 'Linear') then (sp:sampling_base) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is required for non-Linear sampling scales.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>number(sp:first_center_energy) lt number(sp:last_center_energy)</rule_test>
            <rule_message>In the Uniformly_Sampled classes, the first_center value must be less than the last_center value.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <DD_Rule>
        <local_identifier>us_freq</local_identifier>
        <rule_context>sp:Uniformly_Sampled_Frequency</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('frequency')</rule_test>
            <rule_message>The sp:Uniformaly_Sampled_Frequency may only be used when sp:spectral_bin_type is "frequency".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Array_2D_Spectrum', 'Array_3D_Spectrum')) then (//parent::node()[pds:local_identifier=$objid]/pds:Axis_Array/pds:axis_name=sp:axis_name) else true()</rule_test>
            <rule_message>If the referenced object is an array, then sp:axis_name must correspond to the name attribute of one of the Array_Axis classes in that array object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Table_Character', 'Table_Binary', 'Table_Delimited')) then (sp:axis_name = ('Row','Field')) else true()</rule_test>
            <rule_message>Specify "Row" for a spectral table to indicate that the rows constitute uniformly sampled bins.
                          Specify "Field" to indicate that each row contains a complete spectrum and the fields constitute uniformly sample bins.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale = 'Linear') then (not(sp:sampling_base)) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is forbidden if sp:sampling_scale is "Linear".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale ne 'Linear') then (sp:sampling_base) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is required for non-Linear sampling scales.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>number(sp:first_center_frequency) lt number(sp:last_center_frequency)</rule_test>
            <rule_message>In the Uniformly_Sampled classes, the first_center value must be less than the last_center value.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <DD_Rule>
        <local_identifier>us_wavelength</local_identifier>
        <rule_context>sp:Uniformly_Sampled_Wavelength</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('wavelength')</rule_test>
            <rule_message>The sp:Uniformaly_Sampled_Wavelength may only be used when sp:spectral_bin_type is "wavelength".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Array_2D_Spectrum', 'Array_3D_Spectrum')) then (//parent::node()[pds:local_identifier=$objid]/pds:Axis_Array/pds:axis_name=sp:axis_name) else true()</rule_test>
            <rule_message>If the referenced object is an array, then sp:axis_name must correspond to the name attribute of one of the Array_Axis classes in that array object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Table_Character', 'Table_Binary', 'Table_Delimited')) then (sp:axis_name = ('Row','Field')) else true()</rule_test>
            <rule_message>Specify "Row" for a spectral table to indicate that the rows constitute uniformly sampled bins.
                Specify "Field" to indicate that each row contains a complete spectrum and the fields constitute uniformly sample bins.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale = 'Linear') then (not(sp:sampling_base)) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is forbidden if sp:sampling_scale is "Linear".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale ne 'Linear') then (sp:sampling_base) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is required for non-Linear sampling scales.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>number(sp:first_center_wavelength) lt number(sp:last_center_wavelength)</rule_test>
            <rule_message>In the Uniformly_Sampled classes, the first_center value must be less than the last_center value.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <DD_Rule>
        <local_identifier>us_wavenumber</local_identifier>
        <rule_context>sp:Uniformly_Sampled_Wavenumber</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('wavenumber')</rule_test>
            <rule_message>The sp:Uniformaly_Sampled_Wavenumber may only be used when sp:spectral_bin_type is "wavenumber".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Array_2D_Spectrum', 'Array_3D_Spectrum')) then (//parent::node()[pds:local_identifier=$objid]/pds:Axis_Array/pds:axis_name=sp:axis_name) else true()</rule_test>
            <rule_message>If the referenced object is an array, then sp:axis_name must correspond to the name attribute of one of the Array_Axis classes in that array object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = ('Table_Character', 'Table_Binary', 'Table_Delimited')) then (sp:axis_name = ('Row','Field')) else true()</rule_test>
            <rule_message>Specify "Row" for a spectral table to indicate that the rows constitute uniformly sampled bins.
                Specify "Field" to indicate that each row contains a complete spectrum and the fields constitute uniformly sample bins.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale = 'Linear') then (not(sp:sampling_base)) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is forbidden if sp:sampling_scale is "Linear".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:sampling_scale ne 'Linear') then (sp:sampling_base) else true()</rule_test>
            <rule_message>The sp:sampling_base attribute is required for non-Linear sampling scales.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>number(sp:first_center_wavenumber) lt number(sp:last_center_wavenumber)</rule_test>
            <rule_message>In the Uniformly_Sampled classes, the first_center value must be less than the last_center value.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Axis_Bin_Set_(unit type) -->
    
    <DD_Rule>
        <local_identifier>abs_energy_check</local_identifier>
        <rule_context>sp:Axis_Bin_Set_Energy</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="arrayid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('energy')</rule_test>
            <rule_message>The sp:Axis_Bin_Set_Energy class may only be used when sp:spectral_bin_type is "energy".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>((//parent::node()[pds:local_identifier=$arrayid]/pds:Axis_Array/pds:axis_name=sp:axis_name) or (sp:axis_name=('Row','Field')))</rule_test>
            <rule_message>In the Axis_Bin_Set classes, the sp:axis_name value must correspond to the name of an axis in the referenced array object, or contain one of the special values "Row" or "Field".</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <DD_Rule>
        <local_identifier>abs_frequency_check</local_identifier>
        <rule_context>sp:Axis_Bin_Set_Frequency</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="arrayid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('frequency')</rule_test>
            <rule_message>The sp:Axis_Bin_Set_Frequency class may only be used when sp:spectral_bin_type is "frequency".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>((//parent::node()[pds:local_identifier=$arrayid]/pds:Axis_Array/pds:axis_name=sp:axis_name) or (sp:axis_name=('Row','Field')))</rule_test>
            <rule_message>In the Axis_Bin_Set classes, the sp:axis_name value must correspond to the name of an axis in the referenced array object, or contain one of the special values "Row" or "Field".</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <DD_Rule>
        <local_identifier>abs_wavelength_check</local_identifier>
        <rule_context>sp:Axis_Bin_Set_Wavelength</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="arrayid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('wavelength')</rule_test>
            <rule_message>The sp:Axis_Bin_Set_Wavelength class may only be used when sp:spectral_bin_type is "wavelength".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>((//parent::node()[pds:local_identifier=$arrayid]/pds:Axis_Array/pds:axis_name=sp:axis_name) or (sp:axis_name=('Row','Field')))</rule_test>
            <rule_message>In the Axis_Bin_Set classes, the sp:axis_name value must correspond to the name of an axis in the referenced array object, or contain one of the special values "Row" or "Field".</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <DD_Rule>
        <local_identifier>abs_wavenumber_check</local_identifier>
        <rule_context>sp:Axis_Bin_Set_Wavenumber</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <rule_assign>name="arrayid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="binnum" value="count(sp:Bin_Wavenumber)"</rule_assign>
        <rule_assign>name="uniqueseq" value="count(distinct-values(sp:Bin_Wavenumber/sp:bin_sequence_number))"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$spectype = ('wavenumber')</rule_test>
            <rule_message>The sp:Axis_Bin_Set_Wavenumber class may only be used when sp:spectral_bin_type is "wavenumber".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>((//parent::node()[pds:local_identifier=$arrayid]/pds:Axis_Array/pds:axis_name=sp:axis_name) or (sp:axis_name=('Row','Field')))</rule_test>
            <rule_message>In the Axis_Bin_Set classes, the sp:axis_name value must correspond to the name of an axis in the referenced array object, or contain one of the special values "Row" or "Field".</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>$binnum eq $uniqueseq</rule_test>
            <rule_message>In the Axis_Bin_Set class, the bin_sequence_number of each Bin_Wavenumber class must be unique.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_(unit) sequence number checks -->
    
    <DD_Rule>
        <local_identifier>bin_en_seq</local_identifier>
        <rule_context>sp:Bin_Energy</rule_context>
        <rule_assign>name="binnum" value="count(../sp:Bin_Energy)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>sp:bin_sequence_number &amp;gt;= 1 and sp:bin_sequence_number &amp;lt;= $binnum</rule_test>
            <rule_message>In sp:Bin_Energy, bin_sequence_numbers must be between 1 and the number of bins, inclusive.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <DD_Rule>
        <local_identifier>bin_fr_seq</local_identifier>
        <rule_context>sp:Bin_Frequency</rule_context>
        <!--
            This assignment sets $binnum to the number of Bin_Frequency subclasses in the
            class containing the context node.  The "../" notation is shorthand for 
            "parent::node()".
        -->
        <rule_assign>name="binnum" value="count(../sp:Bin_Frequency)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <!--
                This test is checking whether the bin_sequence_number in the context node
                is >=1 and <= the total number of bins.  Note the bizarre coding required
                to get around the special characters ">" and "<" in the test.
            -->
            <rule_test>sp:bin_sequence_number &amp;gt;= 1 and sp:bin_sequence_number &amp;lt;= $binnum</rule_test>
            <rule_message>In sp:Bin_Frequency, bin_sequence_numbers must be between 1 and the number of bins, inclusive.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <DD_Rule>
        <local_identifier>bin_wl_seq</local_identifier>
        <rule_context>sp:Bin_Wavelength</rule_context>
        <rule_assign>name="binnum" value="count(../sp:Bin_Wavelength)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>sp:bin_sequence_number &amp;gt;= 1 and sp:bin_sequence_number &amp;lt;= $binnum</rule_test>
            <rule_message>In sp:Bin_Wavelength, bin_sequence_numbers must be between 1 and the number of bins, inclusive.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <DD_Rule>
        <local_identifier>bin_wn_seq</local_identifier>
        <rule_context>sp:Bin_Wavenumber</rule_context>
        <rule_assign>name="binnum" value="count(../sp:Bin_Wavenumber)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>sp:bin_sequence_number &amp;gt;= 1 and sp:bin_sequence_number &amp;lt;= $binnum</rule_test>
            <rule_message>In sp:Bin_Wavenumber, bin_sequence_numbers must be between 1 and the number of bins, inclusive.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <!-- sp:Spectral_Lookup checks -->
    
    <DD_Rule>
        <local_identifier>bin_unique</local_identifier>
        <!-- This rule does a sanity check to make sure that when a table field provides bin
              centers and widths, the same field isn't inadvertently named for both.
        -->
        <rule_context>sp:Spectral_Lookup</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (sp:Bin_Center_Lookup/sp:bin_center_field_name and sp:Bin_Width_Lookup/sp:bin_width_field_name) then (data(sp:Bin_Center_Lookup/sp:bin_center_field_name) != data(sp:Bin_Width_Lookup/sp:bin_width_field_name)) else true()</rule_test>
            <rule_message>In sp:Spectral_Lookup, sp:bin_center_field_name and sp:bin_width_field_name may not have the same value.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Width_Constant must correspond to spectral_type -->
    
    <DD_Rule>
        <local_identifier>bwc_type</local_identifier>
        <rule_context>sp:Bin_Width_Constant</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <!--
            Note that the tests below work because the 'choice' list defined as part of the Bin_Width_Constant
            class already ensures that only one bin_width_[unit] attribute will be present.  In combination,
            both constructs ensure that only one width attribute can be provided, and it must be in the same units
            of measure type as the spectral data.
        -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='energy') then (sp:bin_width_energy) else true()</rule_test>
            <rule_message>In sp:Bin_Width_Constant, sp:bin_width_energy must be supplied for energy spectra.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='frequency') then (sp:bin_width_frequency) else true()</rule_test>
            <rule_message>In sp:Bin_Width_Constant, sp:bin_width_frequency must be supplied for frequency spectra.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='wavelength') then (sp:bin_width_wavelength) else true()</rule_test>
            <rule_message>In sp:Bin_Width_Constant, sp:bin_width_wavelength must be supplied for wavelength spectra.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='wavenumber') then (sp:bin_width_wavenumber) else true()</rule_test>
            <rule_message>In sp:Bin_Width_Constant, sp:bin_width_wavenumber must be supplied for wavenumber spectra.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Center_Lookup/sp:bin_center_field_name -->

    <DD_Rule>
        <local_identifier>bcl_field</local_identifier>
        <rule_context>sp:Bin_Center_Lookup/sp:bin_center_field_name</rule_context>
        <rule_assign>name="cntfield" value="string(node())"</rule_assign>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <rule_assign>name="specform" value="string(ancestor::sp:Spectral_Characteristics/sp:spectrum_format)"</rule_assign>
        <!-- Table_Character checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Character')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Field_Character/pds:name[data(.)=$cntfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_center_field_name attribute must correspond to the name of exactly Field_Character in the referenced Table_Character object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype = 'Table_Character')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Group_Field_Character/pds:Field_Character/pds:name[data(.)=$cntfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_center_field_name attribute must correspond to the name of exactly one Field_Character inside a Group_Field_Character for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
        <!-- Table_Binary checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Binary')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Field_Binary/pds:name[data(.)=$cntfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_center_field_name attribute must correspond to the name of exactly one Field_Binary in the referenced Table_Binary object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype = 'Table_Binary')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Group_Field_Binary/pds:Field_Binary/pds:name[data(.)=$cntfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_center_field_name attribute must correspond to the name of exactly one Field_Binary inside a Group_Field_Binary for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
        <!-- Table_Delimited checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Delimited')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Field_Delimited/pds:name[data(.)=$cntfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_center_field_name attribute must correspond to the name of exactly one Field_Delimited in the referenced Table_Delimited object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype='Table_Delimited')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Group_Field_Delimited/pds:Field_Delimited/pds:name[data(.)=$cntfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_center_field_name attribute must correspond to the name of exactly one Field_Delimited inside a Group_Field_Delimited for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <!-- sp:Bin_Center_Lookup/sp:bin_center_field_number_list check -->
    
    <DD_Rule>
        <local_identifier>bcllist_eu</local_identifier>
        <rule_context>sp:Bin_Center_Lookup/sp:bin_center_field_number_list</rule_context>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <rule_assign>name="val" value="normalize-space(string())"</rule_assign>
        <rule_assign>name="numlist" value="substring($val,2,string-length($val)-2)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Character') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Field_Character/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:bin_center_field_number_list must correspond to the value of a field_number attribute in a Field_Character definition.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Binary') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Field_Binary/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:bin_center_field_number_list must correspond to the value of a field_number attribute in a Field_Binary definition.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Delimited') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Field_Delimited/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:bin_center_field_number_list must correspond to the value of a field_number attribute in a Field_Delimited definition.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Center_Lookup/pds:Local_Internal_Reference -->

    <DD_Rule>
        <local_identifier>bcl_lir</local_identifier>
        <rule_context>sp:Bin_Center_Lookup/pds:Local_Internal_Reference</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:local_reference_type = ('spectral_characteristics_to_bin_center_values')</rule_test>
            <rule_message>In the sp:Bin_Center_Lookup class, the attribute pds:local_reference_type must be equal to 'spectral_characteristics_to_bin_center_values'.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:local_identifier_reference = //pds:local_identifier</rule_test>
            <rule_message>In sp:Bin_Center_Lookup, the pds:local_identifier_reference must match the pds:local_identifier of a data object in the product label.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Width_Lookup/sp:bin_width_field_name -->

    <DD_Rule>
        <local_identifier>bwl_field</local_identifier>
        <rule_context>sp:Bin_Width_Lookup/sp:bin_width_field_name</rule_context>
        <rule_assign>name="widfield" value="string(node())"</rule_assign>
        <!--
            This is a case where we need to look fairly far back in the document tree to get to the 
            identifier of the referenced data object.  "ancestor::" restricts the search to direct
            ancestors of the context node - i.e., parent, grandparent, great-grandparent, etc.  This
            ensures that the identifier we retrieve came from the same Spectral_Characteristics class 
            we're still in.  This is important in labels where there might be more than one spectral 
            data object, and thus more than one Spectral_Characteristics class.
        -->
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <rule_assign>name="specform" value="string(ancestor::sp:Spectral_Characteristics/sp:spectrum_format)"</rule_assign>
        <!-- Table_Character checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Character')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Field_Character/pds:name[data(.)=$widfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_width_field_name attribute must correspond to the name of exactly Field_Character in the referenced Table_Character object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype = 'Table_Character')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Group_Field_Character/pds:Field_Character/pds:name[data(.)=$widfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_width_field_name attribute must correspond to the name of exactly one Field_Character inside a Group_Field_Character for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
        <!-- Table_Binary checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Binary')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Field_Binary/pds:name[data(.)=$widfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_width_field_name attribute must correspond to the name of exactly one Field_Binary in the referenced Table_Binary object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype = 'Table_Binary')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Group_Field_Binary/pds:Field_Binary/pds:name[data(.)=$widfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_width_field_name attribute must correspond to the name of exactly one Field_Binary inside a Group_Field_Binary for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
        <!-- Table_Delimited checks -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = '1D') and ($objtype = 'Table_Delimited')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Field_Delimited/pds:name[data(.)=$widfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_width_field_name attribute must correspond to the name of exactly one Field_Delimited in the referenced Table_Delimited object.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if (($specform = ('Tabulated-Parameter Groups','Tabulated-Point Group')) and ($objtype='Table_Delimited')) then (count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Group_Field_Delimited/pds:Field_Delimited/pds:name[data(.)=$widfield]) eq 1) else true()</rule_test>
            <rule_message>The sp:bin_width_field_name attribute must correspond to the name of exactly one Field_Delimited inside a Group_Field_Delimited for tabulated spectra with groups.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <!-- sp:Bin_Width_Lookup/sp:bin_width_field_number_list check -->
    
    <DD_Rule>
        <local_identifier>bwllist_eu</local_identifier>
        <rule_context>sp:Bin_Width_Lookup/sp:bin_width_field_number_list</rule_context>
        <rule_assign>name="objid" value="string(ancestor::sp:Spectral_Characteristics/pds:Local_Internal_Reference/pds:local_identifier_reference)"</rule_assign>
        <rule_assign>name="objtype" value="local-name(//parent::node()[pds:local_identifier=$objid])"</rule_assign>
        <rule_assign>name="val" value="normalize-space(string())"</rule_assign>
        <rule_assign>name="numlist" value="substring($val,2,string-length($val)-2)"</rule_assign>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Character') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Character/pds:Field_Character/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:bin_width_field_number_list must correspond to the value of a field_number attribute in a Field_Character definition.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Binary') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Binary/pds:Field_Binary/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:bin_width_field_number_list must correspond to the value of a field_number attribute in a Field_Binary definition.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($objtype = 'Table_Delimited') then (every $n in (tokenize($numlist,'\s*,\s*')) satisfies count(//parent::node()[pds:local_identifier=$objid]/pds:Record_Delimited/pds:Field_Delimited/pds:field_number[data(.)=$n])=1) else true()</rule_test>
            <rule_message>For Tabulated-Flat spectra, every value of sp:bin_width_field_number_list must correspond to the value of a field_number attribute in a Field_Delimited definition.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
    
    <!-- sp:Bin_Width_Lookup/pds:Local_Internal_Reference -->

    <DD_Rule>
        <local_identifier>bwl_lir</local_identifier>
        <rule_context>sp:Bin_Width_Lookup/pds:Local_Internal_Reference</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:local_reference_type = ('spectral_characteristics_to_bin_width_values')</rule_test>
            <rule_message>In the sp:Bin_Width_Lookup class, the attribute pds:local_reference_type must be equal to 'spectral_characteristics_to_bin_width_values'.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:local_identifier_reference = //pds:local_identifier</rule_test>
            <rule_message>In sp:Bin_Width_Lookup, the pds:local_identifier_reference must match the pds:local_identifier of a data object in the product label.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Center_Lookup/pds:Internal_Reference -->

    <DD_Rule>
        <local_identifier>bcl_ir</local_identifier>
        <rule_context>sp:Bin_Center_Lookup/pds:Internal_Reference</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:reference_type = ('spectral_characteristics_to_bin_center_values')</rule_test>
            <rule_message>In the sp:Bin_Center_Lookup class, the attribute pds:reference_type must be equal to 'spectral_characteristics_to_bin_center_values'.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Width_Lookup/pds:Internal_Reference -->

    <DD_Rule>
        <!--
            Here is a dead-simple example of defining a single pds:reference_type value for
            a single context.  Note the correspondence of the reference_type value to the
            context.
        -->
        <local_identifier>bwl_ir</local_identifier>
        <rule_context>sp:Bin_Width_Lookup/pds:Internal_Reference</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:reference_type = ('spectral_characteristics_to_bin_width_values')</rule_test>
            <rule_message>In the sp:Bin_Width_Lookup class, the attribute pds:reference_type must be equal to 'spectral_characteristics_to_bin_width_values'.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Center_Lookup must have one subclass -->

    <DD_Rule>
        <local_identifier>bcl_content</local_identifier>
        <rule_context>sp:Bin_Center_Lookup</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <!--
                count(*) returns the number of child nodes associated with the current context
                node, and reports an error if there is not exactly one child.
                
                Why do it this way?  Because...
            -->
            <rule_test>count(*) = 1</rule_test>
            <!-- 
                Dictionary Preparation Hint: Choice Lists with Attributes AND Classes?
                ======================================================================
                Sort of.
                
                In this class I have a mix of attributes and sub-classes.  LDDTool XSChoice 
                lists are restricted to one element type - either classes or attributes, but 
                not both.  I don't like gratuitous subclasses just to hold a single attribute, 
                so in this case I defined the Bin_Center_Lookup class to have 4 optional 
                children - one attribute and three classes - none of which is allowed to 
                appear more than once by the definition of Bin_Center_Lookup.  Then I added 
                this rule to ensure that exactly one child must be present. The net result is
                effectively the same as being able to define a XSChoice list with both
                attributes and classes, and min/max_occurrences = '1'.
            -->
            <rule_message>In sp:Bin_Center_Lookup, exactly one of sp:bin_center_field_name, pds:Local_Identifier_Reference, or pds:Internal_Reference must be provided.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- sp:Bin_Width_Lookup must have one subclass -->

    <DD_Rule>
        <local_identifier>bwl_content</local_identifier>
        <rule_context>sp:Bin_Width_Lookup</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>count(*) = 1</rule_test>
            <rule_message>In sp:Bin_Width_Lookup, exactly one of sp:bin_width_field_name, sp:bin_width_field_number_list, pds:Local_Identifier_Reference, or pds:Internal_Reference must be provided.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- Field_of_View content -->

    <!-- Field_of_View/pds:Internal_Reference type -->

    <DD_Rule>
        <local_identifier>fov_ir_type</local_identifier>
        <rule_context>sp:Field_of_View/pds:Internal_Reference</rule_context>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>pds:reference_type = ('spectral_characteristics_to_document')</rule_test>
            <rule_message>In sp:Field_of_View, the attribute pds:reference_type must have a value of "spectral_characteristics_to_document".</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>

    <!-- Observation_Parameters: Spectral Resolution Unit must align with bin type -->

    <DD_Rule>
        <local_identifier>obsparm_sr</local_identifier>
        <rule_context>sp:Observation_Parameters</rule_context>
        <rule_assign>name="spectype" value="string(ancestor::sp:Spectral_Characteristics/sp:spectral_bin_type)"</rule_assign>
        <!--
            Note that the tests below work because the 'choice' list defined as part of the Observation_Parameters
            class already ensures that only one resolution_limit_[unit] attribute will be present.  In combination,
            both constructs ensure that only one resolution value can be provided, and it must be in the same units
            of measure type as the spectral data.
        -->
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='energy') then (sp:resolution_limit_energy or not(sp:resolution_limit_frequency or sp:resolution_limit_wavelength or sp:resolution_limit_wavenumber)) else true()</rule_test>
            <rule_message>In sp:Observation_Parameters, only sp:resolution_limit_energy may be included for energy spectra.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='frequency') then (sp:resolution_limit_frequency or not(sp:resolution_limit_energy or sp:resolution_limit_wavelength or sp:resolution_limit_wavenumber)) else true()</rule_test>
            <rule_message>In sp:Observation_Parameters, only sp:resolution_limit_frequency may be included for frequency spectra.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='wavelength') then (sp:resolution_limit_wavelength or not(sp:resolution_limit_energy or sp:resolution_limit_frequency or sp:resolution_limit_wavenumber)) else true()</rule_test>
            <rule_message>In sp:Observation_Parameters, only sp:resolution_limit_wavelength may be included for wavelength spectra.</rule_message>
        </DD_Rule_Statement>
        <DD_Rule_Statement>
            <rule_type>Assert</rule_type>
            <rule_test>if ($spectype='wavenumber') then (sp:resolution_limit_wavenumber or not(sp:resolution_limit_energy or sp_resolution_limit_frequency or sp:resolution_limit_wavelength)) else true()</rule_test>
            <rule_message>In sp:Observation_Parameters, only sp:resolution_limit_wavenumber may be included for wavenumber spectra.</rule_message>
        </DD_Rule_Statement>
    </DD_Rule>
</Ingest_LDD>
